<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32的ISP下载无反应</title>
    <url>/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/STM32%E7%9A%84ISP%E4%B8%8B%E8%BD%BD%E6%97%A0%E5%8F%8D%E5%BA%94/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚草草学完51单片机知识，自以为可以学习STM32了，谁知板子到的第一天就头疼欲裂，按照51的习惯，都会先下载一个流水灯的程序进板子瞅瞅，可我按照视频以及教程，板子下载成功就是没反应。<a id="more"></a> 对于一个新手真的折腾人，我看了网上的问题，甚至去B站的弹幕里找答案，但是都没有解决。正当我快要放弃甚至去退板子的时候，我想起B站里原子的视频开头（我的未来不是梦~~），那魔性但又励志的歌曲，我决定突破这个问题，于是我在原子的官网论坛找到了解决方法。o(╥﹏╥)o</p><hr><h2 id="ISP下载问题所在"><a href="#ISP下载问题所在" class="headerlink" title="ISP下载问题所在"></a>ISP下载问题所在</h2><p>按照正点原子的教程我们先下载一个程序的hex文件，发现成功的，但是板子没有任何反应，期待的跑马灯连屁股都没有。<br></p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在选项字节区，编程到FLASH时写选项字节不要勾选，除此之外，设定选项字节等中的自动增量设定要修改，启动自动增量不要打钩，如图：</p><hr>]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>wifi模块ESP8266-01s入门———调试</title>
    <url>/wifi%E6%A8%A1%E5%9D%97ESP8266-01s%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="ESP8266-AT模式-器件"><a href="#ESP8266-AT模式-器件" class="headerlink" title="ESP8266(AT模式)器件"></a>ESP8266(AT模式)器件</h2><p>CH340 STC自动下载器，如图:<a id="more"></a><img src="/wifi%E6%A8%A1%E5%9D%97ESP8266-01s%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95/1.jpg" title="图示"><br>以及 ESP8266-01s模块，如图：<img src="/wifi%E6%A8%A1%E5%9D%97ESP8266-01s%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95/0.jpg" title="图示"><br>还有若干杜邦线。</p><hr><h2 id="如何调试学习"><a href="#如何调试学习" class="headerlink" title="如何调试学习"></a>如何调试学习</h2><p>登录哔哩哔哩官网搜索海创电子的ESP8266系列视频教学。点击链接：<a href="https://www.bilibili.com/video/BV117411p7ze/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">ESP8266调试</a><br>视频配套的个人博客也可以参考学习，链接如下：<a href="https://blog.csdn.net/daniaoxp/article/details/100976364" target="_blank" rel="noopener">博客资料</a><br></p><hr><h2 id="实验中的问题"><a href="#实验中的问题" class="headerlink" title="实验中的问题"></a>实验中的问题</h2><p>在视频和博客中都有USB-TTL与ESP8266的链接引脚的配对表格：<br></p><table><tr><td>USB-TTL</td><td>ESP8266-01S</td></tr><tr><td>3.3V</td><td>VCC</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>RX</td><td>TX</td></tr><tr><td>TX</td><td>RX</td></tr><tr><td>3.3V</td><td>CH_PD(EN)</td></tr></table>按照博客与视频中的讲解，连接好线路并调试，但是我没有调试成功，这一折腾就是好几天，我仔细对比了博客中所说的调试不成功可能的原因，并一一去实验，发现并没有解决，于是我仔细地翻看视频教学，找到一个细节。视频中讲解到他当时的CH_PD(EN)，也就是使能端并没有接，也调试成功了，但他推荐我们接上，抱着破罐子破摔的态度，我也就尝试了一下，发现真的调试成功了。出现如图：<img src="/wifi%E6%A8%A1%E5%9D%97ESP8266-01s%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95/0.png" title="图示">的样式（回复一个OK，下面有乱码并ready），就调试成功了。<br>注意：<br>1.引脚一定要对应清楚<br>2.调试的时候打开串口，检查COM的口是否对应（在电脑-属性-设备管理器-端口里查看）<br>3.调试过程中ESP8266可能会发烫，这是正常现象，但是建议试验完就拔掉，万一引脚插错了可能烧坏模块。 *** ## 烧录固件（AT指令固件） 视频中需要的AT固件资料不需要找群，只需要去安可信官网，这里直接给出:[AT固件下载地址](https://docs.ai-thinker.com/esp8266/sdk)，找到出厂默认AT固件下载即可。<br>接着打来烧录软件，接上硬件。<img src="/wifi%E6%A8%A1%E5%9D%97ESP8266-01s%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E2%80%94%E8%B0%83%E8%AF%95/2.jpg" title="图示"> >注意的是烧录的时候，ESP8266-01s的IO0引脚一定要接地，我买的下载器是有两个GND脚的（嘿嘿），视频里自己做了另一个接地，这里大家想办法吧。然后调好，串口选好，文件打钩，地址0x0，然后开始，如果是第一次下载会有些慢，反正我差不多1分钟。<p>然后去串口调试助手里尝试一下有没有烧录成功，注意：在烧录成功后，记得复位（一插一拔），同时将之前的Io0口悬空，再开始串口调试，结果返回OK下面有ready就好了。</p><hr><h2 id="WIFI模块的工作模式"><a href="#WIFI模块的工作模式" class="headerlink" title="WIFI模块的工作模式"></a>WIFI模块的工作模式</h2><ol><li>STA模式：相当于模块去连接周围可用WIFI</li><li>AP模式：相当于模块本身开热点给别人连接</li><li>STA+AP:两者兼容。<blockquote><p>前面的123数字也代表着CWMODE的数字</p></blockquote></li></ol><p>利用串口模块发送<br><br>STA模式：<br></p><ol><li>AT+CWMODE=1,设置成STA模式</li><li>AT+CWLAP,扫描附近可用的AP列表（扫描可用WIFI）</li><li>AT+CWJAP=”wifi名称”,”wifi密码”,模块连接周围的某WIFI，并输入密码。返回connect和OK,即为连接成功。</li><li>AT+CWQAP,断开WIFI连接。</li></ol><hr>]]></content>
      <categories>
        <category>WiFi模块</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>初学单片机1</title>
    <url>/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>通过下载的资料文件，今天开始了正式的学习过程，型号是“普中51-单核-A2”，也是我推荐里配图的那个。<a id="more"></a>具体的内容资料里都有，身患懒癌，所以只记录自己学习是遇到的自以为的重点。</p><hr><h2 id="单片机需要什么基础"><a href="#单片机需要什么基础" class="headerlink" title="单片机需要什么基础"></a>单片机需要什么基础</h2><p>1、单片机与以前所学的知识关联很少；<br>2、只需要掌握很基本的数电模电知识，如二进制、十进制、十六进制之间的转换，与、或、非逻辑关系等；<br>3、对各种器件的概念基本上是从0开始；<br>4、如果要用C语言编程，需具备简单的C语言基础；</p><hr><h2 id="C51的数据类型扩充定义"><a href="#C51的数据类型扩充定义" class="headerlink" title="C51的数据类型扩充定义"></a>C51的数据类型扩充定义</h2><p>sfr: 特殊功能寄存器声明<br>sfr16: sfr的16位数据声明<br>sbit: 特殊功能位声明（<em>用处很多，许多引脚都相关</em>，例如，sbit led=P2^0,此处将引脚P20定义为led，后面点亮第一个led灯有所涉及。）<br>bit: 位变量声明</p><hr><h2 id="点亮第一个LED灯"><a href="#点亮第一个LED灯" class="headerlink" title="点亮第一个LED灯"></a>点亮第一个LED灯</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line">sbit led&#x3D;P2^0;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">  led&#x3D;0;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视频里说道，D1-D8一共8个led灯，分别对应P20-P27的8个引脚，从阳极至阴极，在引脚这边阴极和VCC那边阳极的时候，二极管才能发光，这也符合单向导通性。在keil4中建立好工程<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/1.jpg" title="图示"><br>确认编译完成并生成hex文件，然后连接好PC与单片机，打开资料里的烧入软件。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/0.png" title="图示"><br>点击“打开文件”，找到工程的hex文件，最后点击“程序下载”。（如果出现烧入不成功的错误可以去我的博客-初学单片机的障碍-里面瞅瞅有没有解决方法。<br>效果如下：<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/2.jpg" title="图示"><br></p><hr><h2 id="LED闪烁"><a href="#LED闪烁" class="headerlink" title="LED闪烁"></a>LED闪烁</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">typedef unsigned char u8;  &#x2F;&#x2F;0-255</span><br><span class="line">typedef unsigned int u16;  &#x2F;&#x2F;0-65535</span><br><span class="line"></span><br><span class="line">sbit led&#x3D;P2^0;       &#x2F;&#x2F;D1</span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">   while(i--);  </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">   &#123;</span><br><span class="line">    led&#x3D;0;        &#x2F;&#x2F;点亮 </span><br><span class="line">    delay(50000);&#x2F;&#x2F;450ms</span><br><span class="line">    led&#x3D;1;    &#x2F;&#x2F;熄灭</span><br><span class="line">    delay(50000);&#x2F;&#x2F;450ms</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点亮第一个LED灯的基础上，加入延时函数，其实就是为了使灯类似于“跳动”能让你看到。同样的保存hex，然后下载，发现D1灯闪烁，通过在keil4中的调试，大致一亮一灭0.9秒。</p><hr><h2 id="LED灯流水灯"><a href="#LED灯流水灯" class="headerlink" title="LED灯流水灯"></a>LED灯流水灯</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">#include &quot;intrins.h&quot;        &#x2F;&#x2F;左移右移的头文件</span><br><span class="line">typedef unsigned char u8;  &#x2F;&#x2F;0-255</span><br><span class="line">typedef unsigned int u16;  &#x2F;&#x2F;0-65535</span><br><span class="line">#define led P2            &#x2F;&#x2F;将P2引脚全部定义为led，也就是8个灯</span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">   while(i--);  </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">   u8 i&#x3D;0;                &#x2F;&#x2F;定义</span><br><span class="line">  led&#x3D;0xfe;               &#x2F;&#x2F;1111 1110</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">  for(i&#x3D;0;i&lt;7;i++) &#x2F;&#x2F;7次</span><br><span class="line">  &#123;</span><br><span class="line">    led&#x3D;_crol_(led,1);  &#x2F;&#x2F;左移  1111 1101  1111 1011</span><br><span class="line">    delay(50000);  &#x2F;&#x2F;延时，让你能看见</span><br><span class="line">  &#125;</span><br><span class="line">   for(i&#x3D;0;i&lt;7;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    led&#x3D;_cror_(led,1);</span><br><span class="line">    delay(50000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里运用到了左移右移的方法，同时也要注意头文件的引入，不然会编译错误。#define定义也有运用，方便程序的运行。</p><blockquote><p>重点是，定义P2，包含了8个LED灯，在一开始定义led时，0xfe=1111 1110,之前讲过P2^…的引脚为低电平时才亮，此时高位一直到倒数第二位（P27-P21不亮，P1亮）。</p></blockquote><hr><h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">      </span><br><span class="line">typedef unsigned char u8;  </span><br><span class="line">typedef unsigned int u16; </span><br><span class="line"> </span><br><span class="line">sbit beep&#x3D;P1^5;    </span><br><span class="line">    </span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">   while(i--);  </span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">            </span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">  beep&#x3D;~beep;   &#x2F;&#x2F;高低电平不断变化</span><br><span class="line">  delay(100);    &#x2F;&#x2F;1000us</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.改变单片机引脚输出波形的频率，可以调整控制蜂鸣器音调<br>2.改变输出电平的高低电平占空比，可以控制蜂鸣器的声音大小<br>3.51单片机上的蜂鸣器是无源蜂鸣器，也就是需要一定的频率脉冲才能工作，不像有源蜂鸣器，P1^5接入低电平即可。<br>4.可以发现延时函数的值调的越小（频率高），声音越尖锐；值越高（频率越低），声音越重，甚至哒哒哒的，更甚至没声音。</p><blockquote><p>通过调节频率，可以调出任何音调，按道理也就是说调调可以任意调，比如生日歌。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #include &lt;reg51.h&gt;</span><br><span class="line"></span><br><span class="line">#define uint unsigned int </span><br><span class="line">#define uchar unsigned char</span><br><span class="line"></span><br><span class="line">sbit beep &#x3D; P1^5;</span><br><span class="line"></span><br><span class="line">uchar code SONG_TONE[]&#x3D;&#123;212,212,190,212,159,169,212,212,190,212,142,159,</span><br><span class="line">212,212,106,126,159,169,190,119,119,126,159,142,159,0&#125;;</span><br><span class="line">uchar code SONG_LONG[]&#x3D;&#123;9,3,12,12,12,24,9,3,12,12,12,24,</span><br><span class="line">9,3,12,12,12,12,12,9,3,12,12,12,24,0&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;延时函数</span><br><span class="line">void DelayMS(uint x)</span><br><span class="line">&#123;</span><br><span class="line">     uchar t;</span><br><span class="line">     while(x--) for(t&#x3D;0;t&lt;120;t++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;控制音频、节拍函数</span><br><span class="line">void PlayMusic()</span><br><span class="line">&#123;</span><br><span class="line">     uint i&#x3D;0,j,k;</span><br><span class="line">     while(SONG_LONG[i]!&#x3D;0||SONG_TONE[i]!&#x3D;0)</span><br><span class="line"> &#123;   </span><br><span class="line">     for(j&#x3D;0;j&lt;SONG_LONG[i]*20;j++)  &#x2F;&#x2F;播放各个音符，SONG_LONG 为拍子长度</span><br><span class="line">   &#123;</span><br><span class="line">         beep&#x3D;~beep;</span><br><span class="line">         for(k&#x3D;0;k&lt;SONG_TONE[i]&#x2F;3;k++);&#x2F;&#x2F;SONG_TONE 延时表决定了每个音符的频率</span><br><span class="line">   &#125;</span><br><span class="line">    DelayMS(10);</span><br><span class="line">    i++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    beep&#x3D;0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        PlayMusic(); &#x2F;&#x2F;播放生日快乐</span><br><span class="line">        DelayMS(500); &#x2F;&#x2F;播放完后暂停一段时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是从网上粘贴的生日歌的代码，（先放在这，等我研究完，会了再回来写，我还是太菜）。</p><hr><h2 id="静态数码管"><a href="#静态数码管" class="headerlink" title="静态数码管"></a>静态数码管</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line"> u8 code smgduan[]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x7d,0x07,0x7f,0x6f,0x77,0x7c,</span><br><span class="line"> 0x39,0x5e,0x79,0x71&#125;;   &#x2F;&#x2F;code 存放flash，rom</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  P0&#x3D;smgduan[1];&#x2F;&#x2F; 0x06-0000 0110对应b,c高电平共阴极</span><br><span class="line">  while(1)        &#x2F;&#x2F;显示数字1</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数码管的原理，如果是扫码下载的资料可能没有，这里给出链接：<a href="https://www.bilibili.com/video/BV1NW411r7bu?p=22" target="_blank" rel="noopener">数码管</a><br>。我们这里的51单片机是共阴极，所以接口端需要高电平。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/3.jpg" title="图示"></p><blockquote><p>这里强调的是，数码管静态和动态的学习，最好预备有数字电路和模拟电路的基础（数电模电）。不然光看原理可能都一头雾水，我也是学过一些课程所以略有领会。</p></blockquote><p>选择P0端口，其8位引脚分别对应着数码管上的a-g还有小数点。低位对应a，以此类推。16进制数也需要熟悉。</p><hr><h2 id="动态数码管"><a href="#动态数码管" class="headerlink" title="动态数码管"></a>动态数码管</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line">typedef unsigned char u8;</span><br><span class="line">typedef unsigned int u16;</span><br><span class="line"></span><br><span class="line">sbit LSA&#x3D;P2^2;  &#x2F;&#x2F;38译码器</span><br><span class="line">sbit LSB&#x3D;P2^3;</span><br><span class="line">sbit LSC&#x3D;P2^4;</span><br><span class="line"></span><br><span class="line"> u8 code smgduan[]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,</span><br><span class="line"> 0x39,0x5e,0x79,0x71&#125;;   &#x2F;&#x2F;code 存放flash，ROM.共阴极的16进制对应数码管</span><br><span class="line"></span><br><span class="line"> void delay(u16 i)</span><br><span class="line"> &#123;</span><br><span class="line"> while(i--);</span><br><span class="line"> &#125;</span><br><span class="line"> void DigDisplay()</span><br><span class="line"> &#123;</span><br><span class="line">  u8 i;</span><br><span class="line">  for(i&#x3D;0;i&lt;8;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   switch(i)</span><br><span class="line">   &#123;</span><br><span class="line"> case 0:</span><br><span class="line">       LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;0;break;    &#x2F;&#x2F;000 -0</span><br><span class="line"> case 1:</span><br><span class="line">     LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;0;break;&#x2F;&#x2F;001 -1</span><br><span class="line"> case 2:</span><br><span class="line">      LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;0;break;&#x2F;&#x2F;010 -2</span><br><span class="line"> case 3:</span><br><span class="line">     LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;0;break;&#x2F;&#x2F;011 -3</span><br><span class="line"> case 4:</span><br><span class="line">     LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;1;break;    &#x2F;&#x2F;100 -4</span><br><span class="line"> case 5:</span><br><span class="line">     LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;1;break;&#x2F;&#x2F;101 -5</span><br><span class="line"> case 6:</span><br><span class="line">    LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;1;break;&#x2F;&#x2F;110 -6</span><br><span class="line"> case 7:</span><br><span class="line">    LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;1;break;&#x2F;&#x2F;111 -7</span><br><span class="line">&#125;</span><br><span class="line">P0&#x3D;smgduan[i];</span><br><span class="line">delay(100);      &#x2F;&#x2F; 1 ms</span><br><span class="line">P0&#x3D;0x00;        &#x2F;&#x2F;清零</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">   DigDisplay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒癌犯了，视频里解析很清楚，我的理解度可能也没有很深。值得注意的是，与视频中不一样的地方，他的8个LED灯全亮，我的只对应P2^2,P2^3,P2^4三个LED灯，三个引脚，这三个也是控制38译码器的那三个脚。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/4.jpg" title="图示">。</p><hr><h2 id="独立按键控制LED"><a href="#独立按键控制LED" class="headerlink" title="独立按键控制LED"></a>独立按键控制LED</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">typedef unsigned char u8;  &#x2F;&#x2F;0-255</span><br><span class="line">typedef unsigned int u16;  &#x2F;&#x2F;0-65535</span><br><span class="line"></span><br><span class="line">sbit led&#x3D;P2^0;</span><br><span class="line">sbit k1&#x3D;P3^1;</span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">   while(i--);  </span><br><span class="line">&#125;</span><br><span class="line">void keypros()</span><br><span class="line">&#123;</span><br><span class="line">     if(k1&#x3D;&#x3D;0)   &#x2F;&#x2F;按下  低电平通</span><br><span class="line">  &#123;</span><br><span class="line">  delay(1000);&#x2F;&#x2F;10ms ，消抖</span><br><span class="line">   if(k1&#x3D;&#x3D;0)</span><br><span class="line">  &#123;</span><br><span class="line">   led&#x3D;~led; &#x2F;&#x2F;取反，低电平有效</span><br><span class="line">   &#125;</span><br><span class="line">     while(!k1);&#x2F;&#x2F;松开 高电平无效</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">   keypros();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>独立按键的对应：K1-P3^1 ; K2-P3^0 ; K3-P3^2 ; K4-P3^3 ;具体的原理看视频，代码中的keypros()方法就是讲述按下独立按键，消抖操作，按下LED取反亮，然后松开操作while(!K1)。总体不难理解。</p><hr><h2 id="矩阵按键控制数码管"><a href="#矩阵按键控制数码管" class="headerlink" title="矩阵按键控制数码管"></a>矩阵按键控制数码管</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line">typedef unsigned char u8;</span><br><span class="line">typedef unsigned int u16;</span><br><span class="line"></span><br><span class="line">#define GPIO_DIG P0</span><br><span class="line">#define GPIO_KEY P1</span><br><span class="line"></span><br><span class="line"> u8 code smgduan[]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,</span><br><span class="line"> 0x39,0x5e,0x79,0x71&#125;;   &#x2F;&#x2F;code 存放flash，rom</span><br><span class="line"></span><br><span class="line"> u8 KeyValue;</span><br><span class="line"></span><br><span class="line"> void delay(u16 i)</span><br><span class="line"> &#123;</span><br><span class="line">while(i--);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void KeyDown()</span><br><span class="line"> &#123;</span><br><span class="line">    char a&#x3D;0;</span><br><span class="line">GPIO_KEY&#x3D;0x0f;&#x2F;&#x2F;0000 1111  先给高电平0低电平1</span><br><span class="line">if(GPIO_KEY!&#x3D;0x0f) &#x2F;&#x2F;按下某开关后</span><br><span class="line">&#123;</span><br><span class="line">     switch(GPIO_KEY)</span><br><span class="line"> &#123;</span><br><span class="line">   case(0x07): KeyValue&#x3D;0;break;   &#x2F;&#x2F;0000 0111 第一列</span><br><span class="line">   case(0x0b): KeyValue&#x3D;1;break;   &#x2F;&#x2F;0000 1011 第二列</span><br><span class="line">   case(0x0d): KeyValue&#x3D;2;break;   &#x2F;&#x2F;0000 1101 第三列</span><br><span class="line">   case(0x0e): KeyValue&#x3D;3;break;   &#x2F;&#x2F;0000 1110 第四列</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> GPIO_KEY&#x3D;0xf0;&#x2F;&#x2F;1111 0000 再给高电平1低电平0</span><br><span class="line"> switch(GPIO_KEY)</span><br><span class="line"> &#123;</span><br><span class="line">   case(0x70): KeyValue&#x3D;KeyValue;break;  &#x2F;&#x2F;0111 0000 第一行</span><br><span class="line">   case(0xb0): KeyValue&#x3D;KeyValue+4;break; &#x2F;&#x2F;1011 0000 第二行</span><br><span class="line">   case(0xd0): KeyValue&#x3D;KeyValue+8;break; &#x2F;&#x2F;1101 0000 第三行</span><br><span class="line">   case(0xe0): KeyValue&#x3D;KeyValue+12;break;&#x2F;&#x2F;1110 0000 第四行</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> while((a&lt;50)&amp;&amp;(GPIO_KEY!&#x3D;0xf0))&#x2F;&#x2F;松开的判断</span><br><span class="line"> &#123;</span><br><span class="line">     delay(1000);   &#x2F;&#x2F;10ms</span><br><span class="line"> a++;   &#x2F;&#x2F;500ms</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">  while(1)</span><br><span class="line">  &#123;</span><br><span class="line">KeyDown();</span><br><span class="line">GPIO_DIG&#x3D;smgduan[KeyValue];   &#x2F;&#x2F;带入数据到数码管P0口</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵按键的原理还是挺有意思的，视频中画了个4*4的图，4行4列对应8个管脚，如何确定按下的哪一个按键是通过行列扫描，通过视频可以理解原理，我的代码中也附带了我自己的注释帮助理解。后面的松开按键的函数方法是按下按键多少秒，长按可以听到一直没500ms的跳数。<br>下载到板子上之后，效果就是按键显示0-F，16位数字分别对应16个按键。</p><hr><h2 id="8-8LED点阵点亮一灯"><a href="#8-8LED点阵点亮一灯" class="headerlink" title="8*8LED点阵点亮一灯"></a>8*8LED点阵点亮一灯</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;reg51.h&gt;    &#x2F;&#x2F;改成51，因为RCLK在52中重复定义。</span><br><span class="line">#include&lt;intrins.h&gt;    &#x2F;&#x2F;_nop_()的头文件</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;  </span><br><span class="line">typedef unsigned char u8;  </span><br><span class="line"></span><br><span class="line">sbit SRCLK&#x3D;P3^6;    &#x2F;&#x2F; P3^6 IO口 SHCP</span><br><span class="line">sbit RCLK&#x3D;P3^5;     &#x2F;&#x2F; P3^5 IO口 STCP</span><br><span class="line">sbit SER&#x3D;P3^4;      &#x2F;&#x2F; P3^4 IO口 DS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Hc595SendByte(u8 dat) </span><br><span class="line">&#123;</span><br><span class="line">    u8 a;</span><br><span class="line">    SRCLK&#x3D;0;</span><br><span class="line">    RCLK&#x3D;0;</span><br><span class="line">    for(a&#x3D;0;a&lt;8;a++)  &#x2F;&#x2F; 8次循环</span><br><span class="line">    &#123;</span><br><span class="line">        SER&#x3D;dat&gt;&gt;7;  &#x2F;&#x2F;DS等于传入值的最高位 1000 0000 传入1</span><br><span class="line">        dat&lt;&lt;&#x3D;1;   &#x2F;&#x2F;最高位获取过了，将最高位移除，这一次的次高位位下次最高位，下一位0</span><br><span class="line"></span><br><span class="line">        SRCLK&#x3D;1;  &#x2F;&#x2F;SHCP 上升沿</span><br><span class="line">        _nop_();  &#x2F;&#x2F;intrins.h中的方法。</span><br><span class="line">        _nop_();  &#x2F;&#x2F;延时抖动，us级</span><br><span class="line">        SRCLK&#x3D;0;  &#x2F;&#x2F; SHCP 下降沿，什么都不会发生</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RCLK&#x3D;1;        &#x2F;&#x2F; STCP上升沿，移位寄存器的数据输出</span><br><span class="line">    _nop_();</span><br><span class="line">    _nop_();</span><br><span class="line">    RCLK&#x3D;0;         &#x2F;&#x2F; STCP下降沿，移位寄存器的数据输出</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;       </span><br><span class="line">    Hc595SendByte(0x80);  &#x2F;&#x2F;1000 0000 控制第一行的led</span><br><span class="line">    P0&#x3D;0x7f;             &#x2F;&#x2F; 0111 1111 控制第一列led</span><br><span class="line">    while(1);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次实验的代码我看了很久的原理，它需要理解74HC595的工作原理，我觉得相对于很多刚接触单片机的新手（我也是o(╥﹏╥)o），可能会有一些难以理解，包括所说的上升沿，移位寄存器啥的。这些都是因为你没有数电模电（数电多一些）的基础的原因。我也是在大二上学期学习了数电模电课程才对此有那么点理解度，一点一点花时间去理解原理。说这么多就是想说如果没有数电知识，你可能要花更多的时间去理解，如果你有这份毅力，希望继续认真看下去。<br>本次实验的教程讲述的16*16LED点阵，分模块有点难理解，这里给出一个同学的博客讲解：<a href="https://blog.csdn.net/kiramario/article/details/80317031" target="_blank" rel="noopener">8x8 LED矩阵第一个灯</a><br>讲解比较完善，这里我挑重点列出：<br></p><ol><li>SRCLK，引脚号是11，它的作用是，每当它发生一次上升沿，则P34口的电平值会在位移寄存器中左移一位。当下一次上升沿发生时，移位寄存器的所有位都往左移一位。</li><li>RCLK，引脚号12，当它发生一次上升沿，移位寄存器的值会输出到DA-DH（D0-D7），这里注意一下，D7是高位。</li><li>595芯片只有一个输入口，即P34 I/O口，对应SER，引脚号时14</li><li>注意：一个LED不亮的原因，在点阵模块原理图上的J24上，需要将OE口接地，在单片机开发板上J24的OE口一般会跟VCC，需要把套子拔下来将GND与OE相连。（实验证明，把OE悬空不接也是可以亮的，所以得出只要是OE低电平即可）。<br></li></ol><p>通过原理图，我们可以理解8x8的点阵图，列：从左到右P0^0-P0^7（从低到高）,行：从下到上D0-D7（从低到高）。相应的列低电平，行高电平就能点亮某LED灯。比如：使P0=0x7f（0111 1111）,D7=1,即可点亮左上角第一个LED。<br>74HC595的具体作用就是串转并输入：通俗的将就是一次次输入0或1，最后并行输出8位1和0组合，如1011 0100。</p><blockquote><p>学到这，我发现视频中的板子跟我们的板子有区别，具体是很多接线的地方没有了，我们这套板子是初学者用的所以可能更简单，而视频中的视频也相应的有所减少，完整的在之前给过链接B站上的。</p></blockquote><h2 id="用8-8点阵输出图文"><a href="#用8-8点阵输出图文" class="headerlink" title="用8*8点阵输出图文"></a>用8*8点阵输出图文</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit SER&#x3D;P3^4;</span><br><span class="line">sbit CLK&#x3D;P3^5;</span><br><span class="line">sbit SRCLK&#x3D;P3^6;</span><br><span class="line"></span><br><span class="line">u8 code ledwidth[][8]&#x3D;&#123;&#123;0x00,0x00,0x3e,0x41,0x41,0x41,0x3e,0x00&#125;, &#x2F;&#x2F;0      列信息</span><br><span class="line">&#123;0x00,0x00,0x00,0x00,0x21,0x7f,0x01,0x00&#125;, &#x2F;&#x2F;1</span><br><span class="line">&#123;0x00,0x00,0x27,0x45,0x45,0x45,0x39,0x00&#125;, &#x2F;&#x2F;2</span><br><span class="line">&#123;0x00,0x00,0x22,0x49,0x49,0x49,0x36,0x00&#125;, &#x2F;&#x2F;3</span><br><span class="line">&#123;0x00,0x00,0x0c,0x14,0x24,0x7f,0x04,0x00&#125;, &#x2F;&#x2F;4</span><br><span class="line">&#123;0x00,0x00,0x72,0x51,0x51,0x51,0x4e,0x00&#125;, &#x2F;&#x2F;5</span><br><span class="line">&#123;0x00,0x00,0x3e,0x49,0x49,0x49,0x26,0x00&#125;, &#x2F;&#x2F;6</span><br><span class="line">&#123;0x00,0x00,0x40,0x40,0x40,0x4f,0x70,0x00&#125;, &#x2F;&#x2F;7</span><br><span class="line">&#123;0x00,0x00,0x36,0x49,0x49,0x49,0x36,0x00&#125;, &#x2F;&#x2F;8</span><br><span class="line">&#123;0x00,0x00,0x32,0x49,0x49,0x49,0x3e,0x00&#125;, &#x2F;&#x2F;9</span><br><span class="line">&#123;0x00,0x00,0x7F,0x48,0x48,0x30,0x00,0x00&#125;, &#x2F;&#x2F;P</span><br><span class="line">&#123;0x00,0x00,0x7F,0x48,0x4C,0x73,0x00,0x00&#125;, &#x2F;&#x2F;R</span><br><span class="line">&#123;0x00,0x00,0x7F,0x49,0x49,0x49,0x00,0x00&#125;, &#x2F;&#x2F;E</span><br><span class="line">&#123;0x00,0x00,0x3E,0x41,0x41,0x62,0x00,0x00&#125;, &#x2F;&#x2F;C</span><br><span class="line">&#123;0x00,0x00,0x7F,0x08,0x08,0x7F,0x00,0x00&#125;, &#x2F;&#x2F;H</span><br><span class="line">&#123;0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00&#125;, &#x2F;&#x2F;I</span><br><span class="line">&#123;0x00,0x7F,0x10,0x08,0x04,0x7F,0x00,0x00&#125;, &#x2F;&#x2F;N</span><br><span class="line">&#123;0x00,0x12,0x14,0x78,0x14,0x12,0x00,0x00&#125;,  &#x2F;&#x2F;大</span><br><span class="line">&#123;0x00,0x08,0x12,0x01,0xFF,0x00,0x10,0x08&#125;,   &#x2F;&#x2F;小</span><br><span class="line">&#123;0x7F,0x41,0x5D,0x55,0x5D,0x41,0x7F,0x00&#125;,  &#x2F;&#x2F;回</span><br><span class="line"></span><br><span class="line">&#123;0x7C,0x48,0x48,0xFF,0x48,0x48,0x7C,0x00&#125;&#125;;  &#x2F;&#x2F;中</span><br><span class="line"> </span><br><span class="line">u16 ledlength[]&#x3D;&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">    while(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send(u8 n)</span><br><span class="line">&#123;</span><br><span class="line">   u8 i;</span><br><span class="line">   CLK&#x3D;0;</span><br><span class="line">   SRCLK&#x3D;0;</span><br><span class="line">   for(i&#x3D;0;i&lt;8;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    SER&#x3D;n&gt;&gt;7;</span><br><span class="line">    n&lt;&lt;&#x3D;1;</span><br><span class="line">    SRCLK&#x3D;0;</span><br><span class="line">    SRCLK&#x3D;1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">    CLK&#x3D;1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    u16 n,i,j&#x3D;0;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    for(i&#x3D;0;i&lt;100;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(n&#x3D;0;n&lt;8;n++)     &#x2F;&#x2F;内循环的作用就是动态扫描</span><br><span class="line">    &#123;</span><br><span class="line">    P0&#x3D;ledlength[n];   &#x2F;&#x2F; 列当n&#x3D;1，0111 1111</span><br><span class="line">    send(ledwidth[j][n]); &#x2F;&#x2F; 输入[0][0]     ，也就是0x00</span><br><span class="line">    delay(50);     &#x2F;&#x2F;0.5ms      肉眼不可见     </span><br><span class="line">    P0&#x3D;0xff;       &#x2F;&#x2F;刷新清零 ，就是不亮</span><br><span class="line">    send(0x00);       &#x2F;&#x2F;刷新清零</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j++;     &#x2F;&#x2F;重复21个显示图文0-20</span><br><span class="line">    j%&#x3D;21;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个可以当做一个模板来用了，通过代码也可以很清楚，给出行的（上下）的16进制数，然后用列的各个列为0的动态扫描就可以显示出想要的图案。</p><blockquote><p>一学到这我就想起了骚操作，搞个爱心+女孩的名字，8x8的格子名字复杂的话可能不太清楚所以用首字母，然后就是动态显示（❤+嘿嘿嘿）。这里给出一手爱心的，至于名字自己画一下算一下进制数。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;reg52.h&gt;</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit SER&#x3D;P3^4;</span><br><span class="line">sbit CLK&#x3D;P3^5;</span><br><span class="line">sbit SRCLK&#x3D;P3^6;</span><br><span class="line"></span><br><span class="line">u8 code ledwidth[][8]&#x3D;&#123;&#123;0x18,0x3c,0x3e,0x1f,0x3e,0x3c,0x18,0x00&#125;&#125;; </span><br><span class="line">u16 ledlength[]&#x3D;&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">while(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void send(u8 n)</span><br><span class="line">&#123;</span><br><span class="line">   u8 i;</span><br><span class="line">   CLK&#x3D;0;</span><br><span class="line">   SRCLK&#x3D;0;</span><br><span class="line">   for(i&#x3D;0;i&lt;8;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       SER&#x3D;n&gt;&gt;7;</span><br><span class="line">       n&lt;&lt;&#x3D;1;</span><br><span class="line">       SRCLK&#x3D;0;</span><br><span class="line">       SRCLK&#x3D;1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">CLK&#x3D;1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">u16 n,i,j&#x3D;0;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">       for(i&#x3D;0;i&lt;100;i++)</span><br><span class="line">       &#123;</span><br><span class="line">       for(n&#x3D;0;n&lt;8;n++)&#x2F;&#x2F;内循环的作用就是动态扫描</span><br><span class="line">       &#123;</span><br><span class="line">       P0&#x3D;ledlength[n];   &#x2F;&#x2F; 列当n&#x3D;1，0111 1111</span><br><span class="line">       send(ledwidth[j][n]); &#x2F;&#x2F; 输入[0][0]，也就是0x00</span><br><span class="line">       delay(50);&#x2F;&#x2F;0.5ms 肉眼不可见       </span><br><span class="line">       P0&#x3D;0xff;  &#x2F;&#x2F;刷新清零 ，就是不亮</span><br><span class="line">       send(0x00);  &#x2F;&#x2F;刷新清零</span><br><span class="line">       &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        j++;       &#x2F;&#x2F;重复1个显示图文</span><br><span class="line">        j%&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体效果如图：<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA/5.jpg" title="图示"><br>反正效果还是不错的。</p>]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>IP网络技术课程</title>
    <url>/IP%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="课程需要"><a href="#课程需要" class="headerlink" title="课程需要"></a>课程需要</h1><p>因为课程的需求，需要学习IP网络技术内容，学习交换机路由器等组网和些许协议知识<a id="more"></a>。在练习中运用思科Cisco Packet Tracer Student软件进行学习。</p><hr><h2 id="交换机VLAN配置-3500系列交换机）"><a href="#交换机VLAN配置-3500系列交换机）" class="headerlink" title="交换机VLAN配置(3500系列交换机）"></a>交换机VLAN配置(3500系列交换机）</h2><ol><li>进入VLAN配置模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vlan data</span><br></pre></td></tr></table></figure></li><li>建立VLAN(建立VLAN10，命名为work1,且可直接建立不命名。)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(vlan)# vlan 10 name work1</span><br></pre></td></tr></table></figure></li><li>删除VLAN<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vlan database</span><br><span class="line">(vlan)# no vlan 10</span><br></pre></td></tr></table></figure></li><li>分配交换机端口到VLAN<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># configure terminal</span><br><span class="line">(config)# int f0&#x2F;1</span><br><span class="line">(config-if)# switchport access vlan 10</span><br></pre></td></tr></table></figure></li><li>VLAN Trunk配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># configure terminal</span><br><span class="line">(config)# int f0&#x2F;24</span><br><span class="line">(config-if)# switchport mode trunk</span><br><span class="line">(config-if)# switchport trunk allowed vlan 1,10</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="端口聚合配置"><a href="#端口聚合配置" class="headerlink" title="端口聚合配置"></a>端口聚合配置</h2><ol><li>端口聚合<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface range fastEthernet 0&#x2F;23-24</span><br><span class="line">(config-if-range)# channel-group 1 mode on </span><br><span class="line">(config-if-range)# switchport mode trunk</span><br><span class="line">(config-if-range)# switchport trunk allowed vlan 10</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="STP生成树协议"><a href="#STP生成树协议" class="headerlink" title="STP生成树协议"></a>STP生成树协议</h2><ol><li>启用交换机的默认VLAN生成树功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# spanning-tree vlan 1</span><br></pre></td></tr></table></figure></li><li>关闭交换机的默认VLAN生成树功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# no spanning-tree vlan 1</span><br></pre></td></tr></table></figure></li><li>查看生成树情况<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show spanning-tree summary</span><br><span class="line"># show spanning-tree vlan 1</span><br></pre></td></tr></table></figure></li><li>指定根网桥<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# spanning-tree vlan 10 root primary</span><br></pre></td></tr></table></figure></li><li>网桥优先级<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# spanning-tree vlan 10  priority 24768</span><br></pre></td></tr></table></figure></li><li>端口优先级<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config-if)# spanning-tree vlan 10  port-priority 128</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h2><ol><li><p>查看路由表信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show ip route</span><br><span class="line"># show ip route summary</span><br></pre></td></tr></table></figure></li><li><p>配置路由地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface gigabitEthernet 0&#x2F;1</span><br><span class="line">(config-if)# ip address 10.10.10.1 255.255.255.0</span><br><span class="line">(config-if)# no shutdown</span><br></pre></td></tr></table></figure></li><li><p>配置静态路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip route &lt;目的网段&gt;   &lt;子网掩码&gt;   &lt;下一跳地址口&gt;</span><br><span class="line">(config)# ip route 20.20.20.0 255.255.255.0 172.168.10.2</span><br></pre></td></tr></table></figure></li><li><p>单臂路由</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface gigabitEthernet 0&#x2F;1</span><br><span class="line">(config-if)# no shutdown</span><br><span class="line">(config)# interface gigabitEthernet 0&#x2F;1.1</span><br><span class="line">(config-subif)# encapsulation dot1Q 10</span><br><span class="line">(config-subif)# ip address 10.10.10.1 255.255.255.0</span><br><span class="line">(config)# interface gigabitEthernet 0&#x2F;1.2</span><br><span class="line">(config-subif)# encapsulation dot1Q 20</span><br><span class="line">(config-subif)# ip address 20.20.20.1 255.255.255.0</span><br></pre></td></tr></table></figure><blockquote><p>交换机对接的路由器的接口需要配置成Trunk模式，允许VLAN10,20通过。</p></blockquote></li><li><p>环回接口配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface loopback 0</span><br><span class="line">(config-if)# ip address 192.168.100.1 255.255.255.255</span><br></pre></td></tr></table></figure></li><li><p>RIP协议</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# router rip</span><br><span class="line">(config-router)# network 192.168.10.0</span><br><span class="line">(config-router)# network 192.168.20.0</span><br></pre></td></tr></table></figure><blockquote><p>这里的地址是路由器接口处网络地址（参与RIP协议的网络地址）<br><br>两个接口都有网络地址就都写上去，注意单臂路由的子网络地址也要写全。</p></blockquote></li><li><p>选择RIP V2版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# router rip</span><br><span class="line">(config-router)# version 2</span><br><span class="line">(config-router)# no auto-summary</span><br><span class="line">(config-router)# network 192.168.10.0</span><br><span class="line">(config-router)# network 192.168.20.0</span><br><span class="line">清理路由表</span><br><span class="line"># clear ip route*</span><br></pre></td></tr></table></figure></li><li><p>OSPF协议（开放最短路径优先协议）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.启用OSPF协议</span><br><span class="line">(config)# router ospf 1</span><br><span class="line">2.配置路由器的router-id，建议使用loopback地址作为路由器的router-id（没有要求可不配）</span><br><span class="line">(config-router)# router-id &lt;router-id&gt;</span><br><span class="line">3.重启进程确保router-id生效</span><br><span class="line"># clear ip ospf process</span><br><span class="line">4.配置运行OSPF的接口以及所在区域</span><br><span class="line">(config-router)# network &lt;子网号&gt;  &lt;掩码的反码&gt; &lt;区域号&gt;</span><br><span class="line">(config-router)# network 30.10.1.0 0.0.0.255 area 0</span><br><span class="line">5.末节区域</span><br><span class="line">(config)# router ospf 1</span><br><span class="line">(config-router)# area &lt;域编号&gt; stub   &#x2F;&#x2F;配置末节区域</span><br><span class="line">(config-router)# area &lt;域编号&gt; stub no-summary &#x2F;&#x2F;配置完全末节区域</span><br><span class="line">6.配置区域间的路由聚合</span><br><span class="line">(config-router)# area &lt;域编号&gt; range &lt;汇聚网段&gt; &lt;掩码&gt;</span><br><span class="line">(config-router)# area 1 range 50.50.50.0 255.255.255.240</span><br><span class="line">7.重分发其他路由协议</span><br><span class="line">(config-router)# redistribute &lt;其他路由协议&gt; subnets</span><br><span class="line">(config-router)# redistribute connected subnets  &#x2F;&#x2F;重发布携带子网的直连路由</span><br><span class="line">(config-router)# redistribute static subnets     &#x2F;&#x2F;重发布携带子网的静态路由</span><br></pre></td></tr></table></figure></li></ol><hr><ol start="9"><li>ACL（Access Control List）<blockquote><p>标准ACL：1-99, 1000-1499<br><br>扩展ACL：100-199， 1500-1999</p></blockquote></li><li>进入标准ACL配置模式（只能以源地址作为过滤条件）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip access-list standard &lt;acl number&#x2F;name&gt;</span><br><span class="line">定义规则&lt;br&#x2F;&gt;</span><br><span class="line">(config-std nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; host &lt;IP地址&gt;</span><br><span class="line">(config-std nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; any</span><br><span class="line">(config-std nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; &lt;源IP地址网段&gt; &lt;通配符掩码&gt;</span><br></pre></td></tr></table></figure></li><li>进入扩展ACL配置模式（以源地址、目的地址、协议及端口号作为过滤标准）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip access-list extended &lt;acl number&#x2F;name&gt;</span><br><span class="line">定义规则&lt;br&#x2F;&gt;</span><br><span class="line">(config-ext-nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; ip host &lt;源IP地址&gt; host &lt;目的IP地址&gt;</span><br><span class="line">(config-ext-nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; ip any any</span><br><span class="line">(config-ext-nacl)# &lt;rule ID&gt; &lt;permit|deny&gt; ip &lt;源IP地址网段&gt; &lt;通配符掩码&gt; &lt;目的IP地址网段&gt; &lt;通配符掩码&gt;</span><br></pre></td></tr></table></figure></li><li>在接口上绑定ACL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface &lt;接口类型&gt; &lt;接口编号&gt;</span><br><span class="line">(config-if)# ip access-group &lt;acl number&#x2F;name&gt; &lt;out|in&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><ol start="10"><li>NAT配置<blockquote><p>配置静态NAT<br></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip nat inside source static &lt;内部本地地址&gt; &lt;内部全局地址&gt;</span><br><span class="line">在路由器接口上设置NAT内部接口和NAT外部接口(根据要求自己选)</span><br><span class="line">(config)# interface &lt;接口类型&gt; &lt;接口编号&gt;</span><br><span class="line">(config-if)# ip nat inside</span><br><span class="line">(config)# int &lt;接口类型&gt; &lt;接口编号&gt;</span><br><span class="line">(config-if)# ip nat outside</span><br></pre></td></tr></table></figure><blockquote><p>动态NAT配置</p></blockquote></li><li>一对一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# access-list &lt;acl编号&gt; permit &lt;地址网段&gt; &lt;通配符掩码&gt;</span><br><span class="line">(config-if)# ip nat pool &lt;地址池名称&gt; &lt;起始IP地址&gt; &lt;结束IP地址&gt; network &lt;掩码&gt;</span><br><span class="line">(config-if)# ip nat inside source list &lt;内部地址列表编号&gt; pool &lt;地址池名称&gt;</span><br></pre></td></tr></table></figure></li><li>一对多(2种)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# access-list &lt;acl编号&gt; permit &lt;地址网段&gt; &lt;通配符掩码&gt;</span><br><span class="line">(config-if)# ip nat pool &lt;地址池名称&gt; &lt;起始IP地址&gt; &lt;结束IP地址&gt; network &lt;掩码&gt;</span><br><span class="line">(config-if)# ip nat inside source list &lt;内部地址列表编号&gt; pool &lt;地址池名称&gt; overload</span><br></pre></td></tr></table></figure>或者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# access-list &lt;acl编号&gt; permit &lt;地址网段&gt; &lt;通配符掩码&gt;</span><br><span class="line">(config-if)# ip nat inside source list &lt;内部地址列表编号&gt; interface &lt;接口类型&gt; &lt;接口编号&gt; overload</span><br></pre></td></tr></table></figure></li></ol><hr><ol start="11"><li>DHCP配置<blockquote><p>创建DHCP地址池</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip dhcp pool &lt;地址池名称&gt;</span><br><span class="line">(dhcp-config)# network &lt;IP地址网段&gt; &lt;子网掩码&gt;</span><br><span class="line">(dhcp-config)# default-router &lt;默认网关地址&gt;</span><br><span class="line">(dhcp-config)# dns-server &lt;DNS服务器&gt;</span><br></pre></td></tr></table></figure><blockquote><p>设置DHCP池中不被分配的IP地址</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# ip dhcp excluded-address &lt;起始IP地址&gt; &lt;结束IP地址&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在路由器接口上配置接口地址用于默认网关（<em>注意：需要和上面地址池中的默认网关地址一样</em>）</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(config)# interface &lt;接口类型&gt; &lt;接口编号&gt;</span><br><span class="line">(config-if)# ip address &lt;IP地址&gt; &lt;子网掩码&gt;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
      <categories>
        <category>IP</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>初学单片机2</title>
    <url>/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/</url>
    <content><![CDATA[<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><ol><li>概念:CPU在处理某一事件A时，发生了另一事件B请求CPU迅速去处理（中断发生）；<a id="more"></a>CPU暂时中断当前的工作，转去处理事件B（中断响应和中断服务）;待CPU将事件B处理完毕后，再回到原来事件A被中断的地方继续处理事件A（中断返回），这一过程称为中断 。</li><li>中断系统结构：<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/1.png" title="图示"><br><br>通过学习我们了解到中断系统的五个中断源，如下表。<table><tr><td>中断源符号</td><td>名称</td><td>中断引起的原因</td><td>中断号</td></tr><tr><td>/INT0</td><td>外部中断0</td><td>P3.2引脚低电平或下降沿信号</td><td>0</td></tr><tr><td>T0</td><td>定时器0中断</td><td>定时/计数器0计数回0溢出</td><td>1</td></tr><tr><td>/INT1</td><td>外部中断1</td><td>P3.3引脚低电平或下降沿信号</td><td>2</td></tr><tr><td>T1</td><td>定时器1中断</td><td>定时/计数器1计数回0溢出</td><td>3</td></tr><tr><td>TI/RI</td><td>串行口中断</td><td>串行通信完成一帧数据发送或接收引起中断</td><td>4</td></tr></table></li></ol><blockquote><p>表格中五个中断源的优先级也是自上而下，引发一个中断需要有必要的条件。（可以对照结构图推断）。<br></p></blockquote><ol><li>IT0 外部中断0触发方式控制位。<pre><code>当IT0=0时，为电平触发方式。
当IT0=1时，为边沿触发方式（下降沿有效）。</code></pre></li><li>EX0=1; 外部中断0中断请求</li><li>EA=1;总中断开关</li></ol><p>举个程序例子：实现用K3按键中断原本LED灯亮，并</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line">typedef unsigned char u8;  &#x2F;&#x2F;0-255</span><br><span class="line">typedef unsigned int u16;  &#x2F;&#x2F;0-65535</span><br><span class="line"></span><br><span class="line">sbit led&#x3D;P2^0;</span><br><span class="line">sbit k3&#x3D;P3^2;         &#x2F;&#x2F;P3.2引脚，对应外部中断INT0</span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">       while(i--);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Int0Init()        &#x2F;&#x2F;这个函数内容可以写在主函数里面</span><br><span class="line">&#123;</span><br><span class="line">        IT0&#x3D;1;        &#x2F;&#x2F;触发方式1，下降沿有效</span><br><span class="line">        EX0&#x3D;1;        &#x2F;&#x2F;打开外部中断</span><br><span class="line">        EA&#x3D;1;         &#x2F;&#x2F;打开总中断开关</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">       Int0Init();</span><br><span class="line">       while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Int0() interrupt 0         &#x2F;&#x2F;中断函数，0为中断号（见表格）</span><br><span class="line">&#123;</span><br><span class="line">       delay(1000);</span><br><span class="line">       if(k3&#x3D;&#x3D;0)        &#x2F;&#x2F;当按下按键，翻转灯状态</span><br><span class="line">       &#123;</span><br><span class="line">       led&#x3D;~led;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TCON的中断请求标志：</p><table><tr><td>位</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>字节地址</td><td>TF1</td><td>TR1</td><td>TF0</td><td>TR0</td><td>IE1</td><td>IT1</td><td>IE0</td><td>IT0</td></tr></table><ol><li>IT0（TCON.0），外部中断0触发方式控制位。<br><pre><code>当IT0=0时，为电平触发方式。
当IT0=1时，为边沿触发方式（下降沿有效）。</code></pre></li><li>IE0（TCON.1），外部中断0中断请求标志位。</li><li>IT1（TCON.2），外部中断1触发方式控制位。</li><li>IE1（TCON.3），外部中断1中断请求标志位。</li><li>TF0（TCON.5），定时/计数器T0溢出中断请求标志位。</li><li>TF1（TCON.7），定时/计数器T1溢出中断请求标志位。</li><li>TR1 (TCON.6) ，T1运行控制位。TR1=1时，T1工作。TR1=0时，T1停止工作。</li><li>TR0 (TCON.4) ，同上T0；</li></ol><h2 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;</span><br><span class="line"></span><br><span class="line"> typedef unsigned char u8;</span><br><span class="line"> typedef unsigned int u16;</span><br><span class="line"></span><br><span class="line">sbit led&#x3D;P2^0;        &#x2F;&#x2F;D1</span><br><span class="line"></span><br><span class="line">void Timer0Init()        &#x2F;&#x2F;可以直接放到主函数中</span><br><span class="line">&#123;</span><br><span class="line">       TMOD|&#x3D;0x01;       &#x2F;&#x2F;0000 0001         第四位T0运转，高四位置零不运作。</span><br><span class="line">       TH0&#x3D;0xFC;         &#x2F;&#x2F;1111 1100         设置初始值</span><br><span class="line">       TL0&#x3D;0x18;         &#x2F;&#x2F;0001 1000        64536&#x3D;FC18H</span><br><span class="line">       ET0&#x3D;1;        &#x2F;&#x2F;打开外部中断0</span><br><span class="line">       EA&#x3D;1;         &#x2F;&#x2F;总中断开关</span><br><span class="line">       TR0&#x3D;1;       &#x2F;&#x2F; T0运行控制位。TR0&#x3D;1时，T0工作。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> Timer0Init();</span><br><span class="line"> while(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Time0() interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">       static u16 i;  </span><br><span class="line">       TH0&#x3D;0xFC;        &#x2F;&#x2F;1111 1100</span><br><span class="line">       TL0&#x3D;0x18;        &#x2F;&#x2F;0001 1000</span><br><span class="line">       i++;       &#x2F;&#x2F;每累加到1000，也就是1s，执行函数</span><br><span class="line">       if(i&#x3D;&#x3D;1000)         &#x2F;&#x2F;1s</span><br><span class="line">       &#123;</span><br><span class="line">         i&#x3D;0;        &#x2F;&#x2F;清零</span><br><span class="line">         led&#x3D;~led;        &#x2F;&#x2F;小灯翻转1s</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定时器中断的步骤如下：</p></blockquote><ol><li>对TMOD赋值，以确定T0和T1的工作方式。</li><li>计算初值,并将其写入TH0、TL0或TH1、TL1。</li><li>中断方式时，则对EA赋值，开放定时器中断ET0。</li><li>使TR0或TR1置位，启动定时/计数器定时或计数。</li></ol><p>TMOD定时计数寄存器：</p><table><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>GATE</td><td>C/T</td><td>M1</td><td>M0</td><td>GATE</td><td>C/T</td><td>M1</td><td>M0</td></tr></table><p>高四位控制T1，低四位控制T0.</p><ol><li>GATE——门控制。<br>●GATE=1时，由外部中断引脚INT0、INT1来启动定时器T0、T1.<br>当INT0引脚为高电平时TR0置位，启动定时器T0;<br>当INT1引脚为高电平时TR1置位，启动定时器T1。<br>●GATE=0时，仅由TR0,TR1置位分别启动定时器T0、T1。</li><li>C/T=0时，定时模式；C/T=1时，计数模式。</li><li>M1M0 四种模式。<br></li></ol><p>0 0 方式0 13位计数器</p><p>0 1 方式1 16位计数器</p><p>1 0 方式2 自动重装8位计数器</p><p>1 1 方式3 T0分为2个8位独立计数器，T1此时停止计数。</p><hr><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;       &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;        &#x2F;&#x2F;对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void UsartInit()         &#x2F;&#x2F;可以直接写在主程序中</span><br><span class="line">&#123;</span><br><span class="line">         SCON&#x3D;0X50;         &#x2F;&#x2F;SCON设置为工作方式1</span><br><span class="line">         TMOD&#x3D;0X20;         &#x2F;&#x2F;设置计数器工作方式2       0010 0000</span><br><span class="line">         PCON&#x3D;0X80;         &#x2F;&#x2F;波特率加倍1000 0000</span><br><span class="line">         TH1&#x3D;0XF3;       &#x2F;&#x2F;计数器初始值设置，注意波特率是4800的</span><br><span class="line">         TL1&#x3D;0XF3;</span><br><span class="line">         ES&#x3D;1;         &#x2F;&#x2F;打开接收中断</span><br><span class="line">         EA&#x3D;1;         &#x2F;&#x2F;打开总中断</span><br><span class="line">         TR1&#x3D;1;         &#x2F;&#x2F;打开T1计数器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;         </span><br><span class="line">         UsartInit();  &#x2F;&#x2F;         串口初始化</span><br><span class="line">         while(1);         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Usart() interrupt 4         </span><br><span class="line">&#123;</span><br><span class="line">         u8 receiveData;</span><br><span class="line">         if(RI&#x3D;&#x3D;1)       &#x2F;&#x2F;是否接受到数据</span><br><span class="line">         receiveData&#x3D;SBUF;        &#x2F;&#x2F;出去接收到的数据</span><br><span class="line">         RI &#x3D; 0;         &#x2F;&#x2F;清除接收中断标志位</span><br><span class="line">         SBUF&#x3D;receiveData;        &#x2F;&#x2F;将接收到的数据放入到发送寄存器</span><br><span class="line">         while(!TI);       &#x2F;&#x2F;等待发送数据完成</span><br><span class="line">         TI&#x3D;0;       &#x2F;&#x2F;清除发送完成标志位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCON串行口控制寄存器</p><table><tr><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr><tr><td>SM0</td><td>SM1</td><td>SM2</td><td>REN</td><td>TB8</td><td>RB8</td><td>TI</td><td>RI</td></tr></table><p>复制点概念：</p><ol><li>SM0和SM1为工作方式选择位,如图.<br><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/3.png" title="图示"><br></li><li>SM2，多机通信控制位，主要用于方式2和方式3。当接收机的SM2=1时可以利用收到的RB8来控制是否激活RI。</li><li>REN，允许串行接收位。由软件置REN=1，则启动串行口接收数据；若软件置REN=0，则禁止接收。</li><li>TI，发送中断标志位。</li><li>RI，接收中断标志位。</li></ol><p>PCON中的SMOD与串行口工作有关：波特率倍增位。当SMOD=1时，波特率提高一倍。复位时，SMOD=0。<br>如何设置串口：</p><ol><li>确定T1的工作方式（编程TMOD寄存器）；</li><li>计算T1的初值，装载TH1、TL1；</li><li>启动T1（编程TCON中的TR1位）；</li><li>确定串行口控制（编程SCON寄存器）；</li><li>中断申请</li></ol><blockquote><p>关于SBUF，给出链接资料<a href="https://baike.sogou.com/v69375645.htm?fromTitle=SBUF" target="_blank" rel="noopener">SBUF</a>。</p></blockquote><hr><h2 id="IIC总线工作原理"><a href="#IIC总线工作原理" class="headerlink" title="IIC总线工作原理"></a>IIC总线工作原理</h2><p><a href="https://baike.sogou.com/v7668256.htm?fromTitle=I2C%E6%80%BB%E7%BA%BF" target="_blank" rel="noopener">!I2C</a>（Inter－Integrated Circuit）总线是由PHILIPS公司开发的两线式串行总线，用于连接微控制器及其外围设备。<br></p><ol><li>I2C头文件代码代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef __I2C_H_</span><br><span class="line">#define __I2C_H_</span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line"></span><br><span class="line">sbit SCL&#x3D;P2^1;</span><br><span class="line">sbit SDA&#x3D;P2^0;</span><br><span class="line"></span><br><span class="line">void I2cStart();</span><br><span class="line">void I2cStop();</span><br><span class="line">unsigned char I2cSendByte(unsigned char dat);</span><br><span class="line">unsigned char I2cReadByte();</span><br><span class="line">void At24c02Write(unsigned char addr,unsigned char dat);</span><br><span class="line">unsigned char At24c02Read(unsigned char addr);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li>I2C.c文件如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;i2c.h&quot;</span><br><span class="line"></span><br><span class="line">void Delay10us()       &#x2F;&#x2F;用单片机小精灵弄10us延迟函数</span><br><span class="line">&#123;</span><br><span class="line">         unsigned char a,b;</span><br><span class="line">         for(b&#x3D;1;b&gt;0;b--)</span><br><span class="line">         for(a&#x3D;2;a&gt;0;a--);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void I2cStart()        &#x2F;&#x2F;起始信号：在SCL时钟信号在高电平期间SDA信号产生一个下降沿</span><br><span class="line">&#123;</span><br><span class="line">         SDA&#x3D;1;</span><br><span class="line">         Delay10us();</span><br><span class="line">         SCL&#x3D;1;</span><br><span class="line">         Delay10us();       &#x2F;&#x2F;建立时间是SDA保持时间&gt;4.7us</span><br><span class="line">         SDA&#x3D;0;</span><br><span class="line">         Delay10us();         &#x2F;&#x2F;保持时间是&gt;4us</span><br><span class="line">         SCL&#x3D;0;         </span><br><span class="line">         Delay10us();         &#x2F;&#x2F;起始之后SDA和SCL都为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void I2cStop()       &#x2F;&#x2F;终止信号：在SCL时钟信号高电平期间SDA信号产生一个上升沿</span><br><span class="line">&#123;</span><br><span class="line">         SDA&#x3D;0;</span><br><span class="line">         Delay10us();</span><br><span class="line">         SCL&#x3D;1;</span><br><span class="line">         Delay10us();       &#x2F;&#x2F;建立时间大于4.7us</span><br><span class="line">         SDA&#x3D;1;</span><br><span class="line">         Delay10us();         &#x2F;&#x2F;结束之后保持SDA和SCL都为1；表示总线空闲</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char I2cSendByte(unsigned char dat)&#x2F;&#x2F;发送数据</span><br><span class="line">&#123;</span><br><span class="line">         unsigned char a&#x3D;0,b&#x3D;0;         &#x2F;&#x2F;最大255，一个机器周期为1us，最大延时255us。         </span><br><span class="line">         &#x2F;&#x2F;通过I2C发送一个字节。在SCL时钟信号高电平期间，保持发送信号SDA         </span><br><span class="line">         for(a&#x3D;0;a&lt;8;a++)         &#x2F;&#x2F;要发送8位，从最高位开始</span><br><span class="line">         &#123;         &#x2F;&#x2F;起始信号之后SCL&#x3D;0，所以可以直接改变SDA信号</span><br><span class="line">         SDA&#x3D;dat&gt;&gt;7;       &#x2F;&#x2F;将发送的dat一个字节（8位）右移7位，可以把最高位提出赋值给SDA。</span><br><span class="line">         dat&#x3D;dat&lt;&lt;1;       &#x2F;&#x2F;将dat左移一位，把最高位挤出去了</span><br><span class="line">         Delay10us();</span><br><span class="line">         SCL&#x3D;1;        &#x2F;&#x2F;SCL&#x3D;1；SDA保持稳定</span><br><span class="line">         Delay10us();       &#x2F;&#x2F;建立时间&gt;4.7us</span><br><span class="line">         SCL&#x3D;0;       &#x2F;&#x2F;SDA可变动</span><br><span class="line">         Delay10us();        &#x2F;&#x2F;时间大于4us         </span><br><span class="line">         &#125;</span><br><span class="line">         SDA&#x3D;1;         &#x2F;&#x2F;释放数据线</span><br><span class="line">         Delay10us();</span><br><span class="line">         SCL&#x3D;1;         &#x2F;&#x2F;释放时钟线</span><br><span class="line">         while(SDA)        &#x2F;&#x2F;等待应答，也就是等待从设备把SDA拉低</span><br><span class="line">         &#123;</span><br><span class="line">         b++;</span><br><span class="line">         if(b&gt;200)       &#x2F;&#x2F;如果超过2000us没有应答发送失败，或者为非应答，表示接收结束</span><br><span class="line">         &#123;</span><br><span class="line">         SCL&#x3D;0;        &#x2F;&#x2F;拉低</span><br><span class="line">         Delay10us();</span><br><span class="line">         return 0;         &#x2F;&#x2F;通讯失败，返回0</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         SCL&#x3D;0;        &#x2F;&#x2F;应答后，拉低SCL</span><br><span class="line">         Delay10us();</span><br><span class="line">         return 1;       &#x2F;&#x2F;发送成功，返回1</span><br><span class="line">&#125;        &#x2F;&#x2F;备注：发送完一个字节SCL&#x3D;0,SDA&#x3D;1</span><br><span class="line"></span><br><span class="line">unsigned char I2cReadByte()       &#x2F;&#x2F;读取数据</span><br><span class="line">&#123;</span><br><span class="line">         unsigned char a&#x3D;0,dat&#x3D;0;</span><br><span class="line">         SDA&#x3D;1;        &#x2F;&#x2F;起始和发送一个字节之后SCL都是0</span><br><span class="line">         Delay10us();</span><br><span class="line">         for(a&#x3D;0;a&lt;8;a++)  &#x2F;&#x2F;接收8个字节</span><br><span class="line">         &#123;</span><br><span class="line">         SCL&#x3D;1;       &#x2F;&#x2F;拉高，SDA数据稳定</span><br><span class="line">         Delay10us();       &#x2F;&#x2F;dat从1-8地址位，</span><br><span class="line">         dat&lt;&lt;&#x3D;1;        &#x2F;&#x2F;00 01 010</span><br><span class="line">         dat|&#x3D;SDA;       &#x2F;&#x2F;        01 11 </span><br><span class="line">         Delay10us();       &#x2F;&#x2F;或运算</span><br><span class="line">         SCL&#x3D;0;       &#x2F;&#x2F;改变</span><br><span class="line">         Delay10us();</span><br><span class="line">         &#125;</span><br><span class="line">         return dat;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void At24c02Write(unsigned char addr,unsigned char dat)</span><br><span class="line">&#123;</span><br><span class="line">         I2cStart();</span><br><span class="line">         I2cSendByte(0xa0);       &#x2F;&#x2F;发送写器件地址1010 0000</span><br><span class="line">         I2cSendByte(addr);       &#x2F;&#x2F;发送要写入内存地址</span><br><span class="line">         I2cSendByte(dat);        &#x2F;&#x2F;发送数据</span><br><span class="line">         I2cStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char At24c02Read(unsigned char addr)</span><br><span class="line">&#123;</span><br><span class="line">         unsigned char num;</span><br><span class="line">         I2cStart();</span><br><span class="line">         I2cSendByte(0xa0); &#x2F;&#x2F;发送写器件地址</span><br><span class="line">         I2cSendByte(addr); &#x2F;&#x2F;发送要读取的地址</span><br><span class="line">         I2cStart();</span><br><span class="line">         I2cSendByte(0xa1); &#x2F;&#x2F;发送读器件地址</span><br><span class="line">         num&#x3D;I2cReadByte(); &#x2F;&#x2F;读取数据</span><br><span class="line">         I2cStop();</span><br><span class="line">         return num;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>main.c<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**************************************************************************************</span><br><span class="line">实验现象：下载程序后数码管后4位显示0，按K1保存显示的数据，按K2读取上次保存的数据，</span><br><span class="line">        按K3显示数据加一，按K4显示数据清零。最大能写入的数据是255</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line">注意事项：        </span><br><span class="line">***************************************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;reg52.h&quot;       &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line">#include &quot;i2c.h&quot;         </span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;        &#x2F;&#x2F;对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit LSA&#x3D;P2^2;</span><br><span class="line">sbit LSB&#x3D;P2^3;</span><br><span class="line">sbit LSC&#x3D;P2^4;</span><br><span class="line"></span><br><span class="line">sbit k1&#x3D;P3^1;</span><br><span class="line">sbit k2&#x3D;P3^0;</span><br><span class="line">sbit k3&#x3D;P3^2;</span><br><span class="line">sbit k4&#x3D;P3^3;       &#x2F;&#x2F;定义按键端口</span><br><span class="line"></span><br><span class="line">char num&#x3D;0;</span><br><span class="line">u8 disp[4];</span><br><span class="line">u8 code smgduan[10]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;</span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">         while(i--);         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Keypros()</span><br><span class="line">&#123;</span><br><span class="line">         if(k1&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         delay(1000);  &#x2F;&#x2F;消抖处理</span><br><span class="line">         if(k1&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         At24c02Write(1,num);       &#x2F;&#x2F;在地址1内写入数据num</span><br><span class="line">         &#125;</span><br><span class="line">         while(!k1);</span><br><span class="line">         &#125;</span><br><span class="line">         if(k2&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         delay(1000);  &#x2F;&#x2F;消抖处理</span><br><span class="line">         if(k2&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         num&#x3D;At24c02Read(1);        &#x2F;&#x2F;读取EEPROM地址1内的数据保存在num中</span><br><span class="line">         &#125;</span><br><span class="line">         while(!k2);</span><br><span class="line">         &#125;</span><br><span class="line">         if(k3&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         delay(100);  &#x2F;&#x2F;消抖处理</span><br><span class="line">         if(k3&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         num++;         &#x2F;&#x2F;数据加1</span><br><span class="line">         if(num&gt;255)num&#x3D;0;</span><br><span class="line">         &#125;</span><br><span class="line">         while(!k3);</span><br><span class="line">         &#125;</span><br><span class="line">         if(k4&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         delay(1000);  &#x2F;&#x2F;消抖处理</span><br><span class="line">         if(k4&#x3D;&#x3D;0)</span><br><span class="line">         &#123;</span><br><span class="line">         num&#x3D;0;       &#x2F;&#x2F;数据清零</span><br><span class="line">         &#125;</span><br><span class="line">         while(!k4);</span><br><span class="line">         &#125;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void datapros()</span><br><span class="line">&#123;</span><br><span class="line">         disp[0]&#x3D;smgduan[num&#x2F;1000];&#x2F;&#x2F;千位</span><br><span class="line">         disp[1]&#x3D;smgduan[num%1000&#x2F;100];&#x2F;&#x2F;百位</span><br><span class="line">         disp[2]&#x3D;smgduan[num%1000%100&#x2F;10];&#x2F;&#x2F;个位</span><br><span class="line">         disp[3]&#x3D;smgduan[num%1000%100%10];         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DigDisplay()</span><br><span class="line">&#123;</span><br><span class="line">         u8 i;</span><br><span class="line">         for(i&#x3D;0;i&lt;4;i++)</span><br><span class="line">         &#123;</span><br><span class="line">         switch(i)       &#x2F;&#x2F;位选，选择点亮的数码管，</span><br><span class="line">         &#123;</span><br><span class="line">         case(0):</span><br><span class="line">         LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第0位</span><br><span class="line">         case(1):</span><br><span class="line">         LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第1位</span><br><span class="line">         case(2):</span><br><span class="line">         LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第2位</span><br><span class="line">         case(3):</span><br><span class="line">         LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第3位</span><br><span class="line">         &#125;</span><br><span class="line">         P0&#x3D;disp[i];&#x2F;&#x2F;发送数据</span><br><span class="line">         delay(100); &#x2F;&#x2F;间隔一段时间扫描         </span><br><span class="line">         P0&#x3D;0x00;&#x2F;&#x2F;消隐</span><br><span class="line">         &#125;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;         </span><br><span class="line">         while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         Keypros();       &#x2F;&#x2F;按键处理函数</span><br><span class="line">         datapros();       &#x2F;&#x2F;数据处理函数</span><br><span class="line">         DigDisplay();&#x2F;&#x2F;数码管显示函数         </span><br><span class="line">         &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>I2C总线通过上拉电阻接正电源。当总线空闲时，两根线均为高电平。</li><li>I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。即，SCL=1时，SDA稳定；SCL=0时，SDA可以变化。</li><li>起始信号和终止信号，相应和非响应（原理看PPT），如图，<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/4.png" title="图示"><br></li></ol><hr><h2 id="DS18B20温度传感器"><a href="#DS18B20温度传感器" class="headerlink" title="DS18B20温度传感器"></a>DS18B20温度传感器</h2><ol><li>主函数main.c代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;         &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line">#include &quot;temp.h&quot;        </span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;       &#x2F;&#x2F;对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit LSA&#x3D;P2^2;</span><br><span class="line">sbit LSB&#x3D;P2^3;</span><br><span class="line">sbit LSC&#x3D;P2^4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 code smgduan[10]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;</span><br><span class="line">u8 num&#x3D;0,DisplayData[8];</span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">        while(i--);        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void datapros(int temp)</span><br><span class="line">&#123;       </span><br><span class="line">         float tp;        </span><br><span class="line">         if(temp&lt;0)         &#x2F;&#x2F;温度数据处理       </span><br><span class="line">         &#123;</span><br><span class="line">        DisplayData[0]&#x3D;0x40;       &#x2F;&#x2F;显示负号</span><br><span class="line">        temp&#x3D;temp-1;</span><br><span class="line">        temp&#x3D;~temp;</span><br><span class="line">        tp&#x3D;temp;</span><br><span class="line">        temp&#x3D;tp*0.0625*100+0.5;  </span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">        DisplayData[0]&#x3D;0x00;</span><br><span class="line">        tp&#x3D;temp;</span><br><span class="line">        temp&#x3D;tp*0.0625*100+0.5;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        DisplayData[1]&#x3D;smgduan[temp%10000&#x2F;1000];&#x2F;&#x2F;十位</span><br><span class="line">        DisplayData[2]&#x3D;smgduan[temp%1000&#x2F;100]|0x80;&#x2F;&#x2F;个位</span><br><span class="line">        DisplayData[3]&#x3D;smgduan[temp%100&#x2F;10];   &#x2F;&#x2F;小数点后1位</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void DigDisplay()</span><br><span class="line">&#123;</span><br><span class="line">        u8 i;</span><br><span class="line">        for(i&#x3D;0;i&lt;6;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        switch(i)         &#x2F;&#x2F;位选，选择点亮的数码管，</span><br><span class="line">        &#123;</span><br><span class="line">        case(0):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第0位</span><br><span class="line">        case(1):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;0; break;&#x2F;&#x2F;显示第1位</span><br><span class="line">        case(2):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第2位</span><br><span class="line">        case(3):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;0; break;&#x2F;&#x2F;显示第3位</span><br><span class="line">        case(4):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;1; break;&#x2F;&#x2F;显示第4位</span><br><span class="line">        case(5):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;1; break;&#x2F;&#x2F;显示第5位</span><br><span class="line">        &#125;</span><br><span class="line">        P0&#x3D;DisplayData[i];&#x2F;&#x2F;发送数据         改变数字显示位置</span><br><span class="line">        delay(100);       &#x2F;&#x2F;间隔一段时间扫描        </span><br><span class="line">        P0&#x3D;0x00;        &#x2F;&#x2F;消隐</span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;        </span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        datapros(Ds18b20ReadTemp());    &#x2F;&#x2F;数据处理函数</span><br><span class="line">        DigDisplay();       &#x2F;&#x2F;数码管显示函数        </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li>温度传感器代码temp.c部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;temp.h&quot;</span><br><span class="line"></span><br><span class="line">void Delay1ms(uint y)         &#x2F;&#x2F;带参数y</span><br><span class="line">&#123;</span><br><span class="line">    uint x;</span><br><span class="line">      for(;y&gt;0;y--)       &#x2F;&#x2F;控制延时几个1ms</span><br><span class="line">      &#123;</span><br><span class="line">         for(x&#x3D;110;x&gt;0;x--);       &#x2F;&#x2F;延时1ms</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar Ds18b20Init()        &#x2F;&#x2F;DS18B20初始化</span><br><span class="line">&#123;</span><br><span class="line">   uchar i&#x3D;0;</span><br><span class="line">   DSPORT&#x3D;0;</span><br><span class="line">   i&#x3D;70;</span><br><span class="line">   while(i--);          &#x2F;&#x2F;642us</span><br><span class="line">   DSPORT&#x3D;1;      &#x2F;&#x2F;拉高</span><br><span class="line">   i&#x3D;0;</span><br><span class="line">   while(DSPORT);</span><br><span class="line">   &#123;</span><br><span class="line">        Delay1ms(1);</span><br><span class="line">        i++;</span><br><span class="line">        if(i&gt;5)</span><br><span class="line">        &#123;</span><br><span class="line">       return 0;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 1;      &#x2F;&#x2F;1存在  0不存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ds18b20WriteByte(uchar dat)       &#x2F;&#x2F;写字节时序</span><br><span class="line">&#123;</span><br><span class="line">   uchar i,j;</span><br><span class="line">   for(j&#x3D;0;j&lt;8;j++)      &#x2F;&#x2F;8字节</span><br><span class="line">   &#123;</span><br><span class="line">           DSPORT&#x3D;0;</span><br><span class="line">        i++;      &#x2F;&#x2F;小延时</span><br><span class="line">        DSPORT&#x3D;dat&amp;0x01;      &#x2F;&#x2F;取最低位，与运算</span><br><span class="line">        i&#x3D;6;</span><br><span class="line">        while(i--);       &#x2F;&#x2F;68us</span><br><span class="line">        DSPORT&#x3D;1;      &#x2F;&#x2F;拉高</span><br><span class="line">        dat&gt;&gt;&#x3D;1;      &#x2F;&#x2F;将最低位移出去，移位操作</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar Ds18b20ReadByte()         &#x2F;&#x2F;读取字节</span><br><span class="line">&#123;</span><br><span class="line">      uint i,j;</span><br><span class="line">        uchar bi,byte;</span><br><span class="line">        for(j&#x3D;8;j&gt;0;j--)</span><br><span class="line">        &#123;</span><br><span class="line">          DSPORT&#x3D;0;</span><br><span class="line">      i++;         &#x2F;&#x2F;  &gt;1us</span><br><span class="line">      DSPORT&#x3D;1;</span><br><span class="line">      i++;         &#x2F;&#x2F;byte&#x3D;1000 0000右移0100 0000   DSPORT&#x3D;0；</span><br><span class="line">      i++;</span><br><span class="line">      bi&#x3D;DSPORT;</span><br><span class="line">      byte&#x3D;(byte&gt;&gt;1)|(bi&lt;&lt;7);   &#x2F;&#x2F;bi左移7位，到最高位</span><br><span class="line">      i&#x3D;4;</span><br><span class="line">      while(i--);              &#x2F;&#x2F;45us</span><br><span class="line">        &#125;</span><br><span class="line">        return byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ds18b20ChangeTemp()       &#x2F;&#x2F;温度转换</span><br><span class="line">&#123;</span><br><span class="line">      Ds18b20Init();</span><br><span class="line">      Delay1ms(1);</span><br><span class="line">      Ds18b20WriteByte(0xcc);       &#x2F;&#x2F;开始温度转换</span><br><span class="line">      Ds18b20WriteByte(0x44);       &#x2F;&#x2F;启动温度传感器转换</span><br><span class="line"></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">void Ds18b20ReadTempCom()      &#x2F;&#x2F;读取数据</span><br><span class="line">&#123;</span><br><span class="line">   Ds18b20Init();</span><br><span class="line">      Delay1ms(1);</span><br><span class="line">      Ds18b20WriteByte(0xcc);       &#x2F;&#x2F;开始温度转换</span><br><span class="line">      Ds18b20WriteByte(0xBE);       &#x2F;&#x2F;读取温度数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Ds18b20ReadTemp()       &#x2F;&#x2F;真正读取温度</span><br><span class="line">&#123;</span><br><span class="line">   int temp&#x3D;0;</span><br><span class="line">   uchar tmh,tml;</span><br><span class="line">   Ds18b20ChangeTemp();</span><br><span class="line">   Ds18b20ReadTempCom();</span><br><span class="line">   tml&#x3D;Ds18b20ReadByte();        &#x2F;&#x2F;低字节</span><br><span class="line">   tmh&#x3D;Ds18b20ReadByte();         &#x2F;&#x2F;高字节</span><br><span class="line">   temp&#x3D;tmh;        </span><br><span class="line">   temp&lt;&lt;&#x3D;8;        &#x2F;&#x2F;高8位已经过去</span><br><span class="line">   temp|&#x3D;tml;        &#x2F;&#x2F;把温度低八位也弄进去</span><br><span class="line">   return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>头文件temp.h部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _temp_H</span><br><span class="line">#define _temp_H</span><br><span class="line"></span><br><span class="line">#include &lt;reg52.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef uchar</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef uint                   &#x2F;&#x2F;用uint代替</span><br><span class="line">#define uint unsigned int      &#x2F;&#x2F;定义无符号整形</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">sbit DSPORT&#x3D;P3^7;          &#x2F;&#x2F;传感器I&#x2F;O口对应P37</span><br><span class="line"></span><br><span class="line">int Ds18b20ReadTemp();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><ol><li>temp.c部分原理<br></li></ol></blockquote></li><li>DS18B20的初始化：<br><br>(1).数据线拉到低电平“0”。<br><br>(2).延时480微妙（该时间的时间范围可以从480到960微妙）。<br><br>(3).数据线拉到高电平“1”。<br><br>(4).延时等待80微妙。如果初始化成功则在15到60微妙时间内产生一个由DS18B20所返回的低电平“0”.根据该状态可以来确定它的存在，但是应注意不能无限的进行等待，不然会使程序进入死循环，所以要进行超时判断。<br><br>(5).若CPU读到了数据线上的低电平“0”后，还要做延时，其延时的时间从发出的高电平算起（第（3）步的时间算起）最少要480微妙。<br><br>时序图：<br><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/5.png" title="图示"></li><li>DS18B20写时序：<br><br>(1).数据线先置低电平“0”<br><br>(2).延时15微妙。<br><br>(3).按从低位到高位的顺序发送数据(一次只发送一位)。<br><br>(4).延时60微妙。<br><br>(5).将数据线拉到高电平。<br><br>(6).重复1～5步骤，直到发送完整的字节。<br><br>(7).最后将数据线拉高。<br><br>时序图：<br><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/7.png" title="图示"></li><li>DS18B20读时序：<br><br>(1).将数据线拉低“0”。<br><br>(2).延时1微妙。<br><br>(3).将数据线拉高“1”,释放总线准备读数据。<br><br>(4).延时10微妙。<br><br>(5).读数据线的状态得到1个状态位，并进行数据处理。<br><br>(6).延时45微妙。<br><br>(7).重复1～7步骤，直到读完一个字节。<br><br>时序图：<br><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/6.png" title="图示"><blockquote><ol start="2"><li>温度转换</li></ol></blockquote></li><li>这是12位转化后得到的12位数据，存储在DS18B20的两个8位的RAM中，高字节的前5位是符号位，如果测得的温度大于0，这5位为‘0’，只要将测到的数值乘以0.0625即可得到实际温度；如果温度小于0，这5位为‘1’，测到的数值需要先减1再取反再乘以0.0625即可得到实际温度。如图：<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/8.png" title="图示"><br><br>举个例子：85度=0000 0101 0101 0000<br><br>前五位为0+1x2^6+1x2^4+1x2^2+1x2^0=64+16+4+1=85.</li></ol><hr><h2 id="液晶1602显示"><a href="#液晶1602显示" class="headerlink" title="液晶1602显示"></a>液晶1602显示</h2><p>效果如图：<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/9.jpg" title="图示"></p><ol><li>主程序代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #include &quot;reg52.h&quot;           &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line">#include &quot;lcd.h&quot;</span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;         &#x2F;&#x2F;对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">u8 Disp[]&#x3D;&quot;    my blog     &quot;;</span><br><span class="line">u8 Disp2[]&#x3D;&quot;   cjl52.top    &quot;;</span><br><span class="line"></span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">       u8 i,j;</span><br><span class="line">       LcdInit();</span><br><span class="line">       LcdWriteCom(0x80);         &#x2F;&#x2F;设置数据指针起点：第一行</span><br><span class="line">       </span><br><span class="line">       for(i&#x3D;0;i&lt;16;i++)</span><br><span class="line">       &#123;</span><br><span class="line">       LcdWriteData(Disp[i]);       </span><br><span class="line">       &#125;</span><br><span class="line">       Lcd1602_Delay1ms(5);</span><br><span class="line">       </span><br><span class="line">       LcdWriteCom(0x80+0x40);         &#x2F;&#x2F;设置数据指针起点：第二行</span><br><span class="line">       for(j&#x3D;0;j&lt;16;j++)</span><br><span class="line">       &#123;</span><br><span class="line">       LcdWriteData(Disp2[j]);       </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       while(1);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>lcd.c液晶原理代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;lcd.h&quot;</span><br><span class="line"></span><br><span class="line">void Lcd1602_Delay1ms(uint c)       &#x2F;&#x2F;误差 0us          延时1ms</span><br><span class="line">&#123;</span><br><span class="line">    uchar a,b;</span><br><span class="line">        for (; c&gt;0; c--)</span><br><span class="line">        &#123;</span><br><span class="line">         for (b&#x3D;199;b&gt;0;b--)</span><br><span class="line">         &#123;</span><br><span class="line">                  for(a&#x3D;1;a&gt;0;a--);</span><br><span class="line">         &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifndef         LCD1602_4PINS         &#x2F;&#x2F;当没有定义这个LCD1602_4PINS时</span><br><span class="line">void LcdWriteCom(uchar com)          &#x2F;&#x2F;写入命令</span><br><span class="line">&#123;</span><br><span class="line">        LCD1602_E &#x3D; 0;     &#x2F;&#x2F;使能</span><br><span class="line">        LCD1602_RS &#x3D; 0;           &#x2F;&#x2F;选择发送命令</span><br><span class="line">        LCD1602_RW &#x3D; 0;           &#x2F;&#x2F;选择写入</span><br><span class="line">        </span><br><span class="line">        LCD1602_DATAPINS &#x3D; com;     &#x2F;&#x2F;放入命令          P0 是LCD1602_DATAPINS </span><br><span class="line">        Lcd1602_Delay1ms(1);        &#x2F;&#x2F;等待数据稳定</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;                  &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);          &#x2F;&#x2F;保持时间</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">#else </span><br><span class="line">void LcdWriteCom(uchar com)          &#x2F;&#x2F;写入命令</span><br><span class="line">&#123;</span><br><span class="line">        LCD1602_E &#x3D; 0;         &#x2F;&#x2F;使能清零</span><br><span class="line">        LCD1602_RS &#x3D; 0;         &#x2F;&#x2F;选择写入命令</span><br><span class="line">        LCD1602_RW &#x3D; 0;         &#x2F;&#x2F;选择写入</span><br><span class="line"></span><br><span class="line">        LCD1602_DATAPINS &#x3D; com;        &#x2F;&#x2F;由于4位的接线是接到P0口的高四位，所以传送高四位不用改</span><br><span class="line">        Lcd1602_Delay1ms(1);</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;         &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        LCD1602_DATAPINS &#x3D; com &lt;&lt; 4; &#x2F;&#x2F;发送低四位</span><br><span class="line">        Lcd1602_Delay1ms(1);</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;         &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">#ifndef         LCD1602_4PINS           </span><br><span class="line">void LcdWriteData(uchar dat)        &#x2F;&#x2F;写入数据</span><br><span class="line">&#123;</span><br><span class="line">        LCD1602_E &#x3D; 0;        &#x2F;&#x2F;使能清零</span><br><span class="line">        LCD1602_RS &#x3D; 1;        &#x2F;&#x2F;选择输入数据</span><br><span class="line">        LCD1602_RW &#x3D; 0;        &#x2F;&#x2F;选择写入</span><br><span class="line"></span><br><span class="line">        LCD1602_DATAPINS &#x3D; dat; &#x2F;&#x2F;写入数据</span><br><span class="line">        Lcd1602_Delay1ms(1);</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;   &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);   &#x2F;&#x2F;保持时间</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">void LcdWriteData(uchar dat)        &#x2F;&#x2F;写入数据</span><br><span class="line">&#123;</span><br><span class="line">        LCD1602_E &#x3D; 0;          &#x2F;&#x2F;使能清零</span><br><span class="line">        LCD1602_RS &#x3D; 1;          &#x2F;&#x2F;选择写入数据</span><br><span class="line">        LCD1602_RW &#x3D; 0;          &#x2F;&#x2F;选择写入</span><br><span class="line"></span><br><span class="line">        LCD1602_DATAPINS &#x3D; dat;        &#x2F;&#x2F;由于4位的接线是接到P0口的高四位，所以传送高四位不用改</span><br><span class="line">        Lcd1602_Delay1ms(1);</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;          &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        LCD1602_DATAPINS &#x3D; dat&lt;&lt;4; &#x2F;&#x2F;写入低四位</span><br><span class="line">        Lcd1602_Delay1ms(1);</span><br><span class="line"></span><br><span class="line">        LCD1602_E &#x3D; 1;          &#x2F;&#x2F;写入时序</span><br><span class="line">        Lcd1602_Delay1ms(5);</span><br><span class="line">        LCD1602_E &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">         </span><br><span class="line">#ifndef        LCD1602_4PINS</span><br><span class="line">void LcdInit()          &#x2F;&#x2F;LCD初始化子程序</span><br><span class="line">&#123;</span><br><span class="line">         LcdWriteCom(0x38);  &#x2F;&#x2F;开显示</span><br><span class="line">        LcdWriteCom(0x0c);  &#x2F;&#x2F;开显示不显示光标</span><br><span class="line">        LcdWriteCom(0x06);  &#x2F;&#x2F;写一个指针加1</span><br><span class="line">        LcdWriteCom(0x01);  &#x2F;&#x2F;清屏</span><br><span class="line">        LcdWriteCom(0x80);  &#x2F;&#x2F;设置数据指针起点</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">void LcdInit()          &#x2F;&#x2F;LCD初始化子程序</span><br><span class="line">&#123;</span><br><span class="line">        LcdWriteCom(0x32);         &#x2F;&#x2F;将8位总线转为4位总线</span><br><span class="line">        LcdWriteCom(0x28);         &#x2F;&#x2F;在四位线下的初始化</span><br><span class="line">        LcdWriteCom(0x0c);  &#x2F;&#x2F;开显示不显示光标</span><br><span class="line">        LcdWriteCom(0x06);  &#x2F;&#x2F;写一个指针加1</span><br><span class="line">        LcdWriteCom(0x01);  &#x2F;&#x2F;清屏</span><br><span class="line">        LcdWriteCom(0x80);  &#x2F;&#x2F;设置数据指针起点</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li>lcd.h头文件代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef __LCD_H_</span><br><span class="line">#define __LCD_H_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;#define LCD1602_4PINS     当使用的是4位数据传输的时候定义，就是有转接板（像TTL-USB）,使用8位取消这个定义(有转接板定义，无转接板注释掉)</span><br><span class="line"></span><br><span class="line">#include&lt;reg52.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef uchar</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef uint </span><br><span class="line">#define uint unsigned int</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define LCD1602_DATAPINS P0    &#x2F;&#x2F;定义接口</span><br><span class="line">sbit LCD1602_E&#x3D;P2^7;</span><br><span class="line">sbit LCD1602_RW&#x3D;P2^5;</span><br><span class="line">sbit LCD1602_RS&#x3D;P2^6;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Lcd1602_Delay1ms(uint c);   &#x2F;&#x2F;误差 0us</span><br><span class="line"></span><br><span class="line">void LcdWriteCom(uchar com);    &#x2F;&#x2F;LCD1602写入8位命令子函数</span><br><span class="line">                </span><br><span class="line">void LcdWriteData(uchar dat);   &#x2F;&#x2F;LCD1602写入8位数据子函数</span><br><span class="line">                </span><br><span class="line">void LcdInit();                         &#x2F;&#x2F;LCD1602初始化子程序                           </span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>原理PPT里的知识很多，我找到了网上一篇精简的（懒人行为）：<a href="https://wenku.baidu.com/view/435c3ba0284ac850ad024299.html" target="_blank" rel="noopener">液晶1602原理</a>.</p></blockquote></li></ol><hr><h2 id="红外原理"><a href="#红外原理" class="headerlink" title="红外原理"></a>红外原理</h2><p>实验现象：按遥控器上某按键会显示其按键的16进制数据码。如图:<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/10.jpg" title="图示"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;                          &#x2F;&#x2F;此文件中定义了单片机的一些特殊功能寄存器</span><br><span class="line">                </span><br><span class="line">typedef unsigned int u16;                  &#x2F;&#x2F;对数据类型进行声明定义</span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit LSA&#x3D;P2^2;                   &#x2F;&#x2F;之前的38译码器</span><br><span class="line">sbit LSB&#x3D;P2^3;</span><br><span class="line">sbit LSC&#x3D;P2^4;</span><br><span class="line"></span><br><span class="line">sbit IRIN&#x3D;P3^2;                 &#x2F;&#x2F;P32口为数据传输口</span><br><span class="line"></span><br><span class="line">u8 IrValue[6];</span><br><span class="line">u8 Time;</span><br><span class="line"></span><br><span class="line">u8 DisplayData[8];</span><br><span class="line">u8 code smgduan[17]&#x3D;&#123;</span><br><span class="line">0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,</span><br><span class="line">0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0X76&#125;;     &#x2F;&#x2F;0、1、2、3、4、5、6、7、8、9、A、b、C、d、E、F、H的显示码</span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">                while(i--);                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DigDisplay()                &#x2F;&#x2F;之前的数码管显示</span><br><span class="line">&#123;</span><br><span class="line">                u8 i;</span><br><span class="line">                for(i&#x3D;0;i&lt;3;i++)</span><br><span class="line">                &#123;</span><br><span class="line">         switch(i)                    &#x2F;&#x2F;位选，选择点亮的数码管，</span><br><span class="line">         &#123;</span><br><span class="line">                         case(0):</span><br><span class="line">         LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;1; break;   &#x2F;&#x2F;显示第0位                </span><br><span class="line">                         case(1):</span><br><span class="line">         LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;1; break;   &#x2F;&#x2F;显示第1位</span><br><span class="line">                         case(2):</span><br><span class="line">         LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;1; break;   &#x2F;&#x2F;显示第2位 </span><br><span class="line">         &#125;</span><br><span class="line">         P0&#x3D;DisplayData[i];&#x2F;&#x2F;发送数据</span><br><span class="line">         delay(100); &#x2F;&#x2F;间隔一段时间扫描                </span><br><span class="line">         P0&#x3D;0x00;&#x2F;&#x2F;消隐</span><br><span class="line">                &#125;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IrInit()                &#x2F;&#x2F;初始化，因为P32口也是外部中断0的接口</span><br><span class="line">&#123;</span><br><span class="line">                IT0&#x3D;1;  &#x2F;&#x2F;下降沿触发</span><br><span class="line">                EX0&#x3D;1;  &#x2F;&#x2F;打开中断0允许</span><br><span class="line">                EA&#x3D;1;                &#x2F;&#x2F;打开总中断</span><br><span class="line"></span><br><span class="line">                IRIN&#x3D;1; &#x2F;&#x2F;初始化端口 上拉高电平</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;                </span><br><span class="line">                IrInit(); </span><br><span class="line">                while(1)</span><br><span class="line">                &#123;                </span><br><span class="line">         DisplayData[0] &#x3D; smgduan[IrValue[2]&#x2F;16]; &#x2F;&#x2F;÷16得到16进制高位</span><br><span class="line">         DisplayData[1] &#x3D; smgduan[IrValue[2]%16]; &#x2F;&#x2F;%16得到16进制低位</span><br><span class="line">         DisplayData[2] &#x3D; smgduan[16];           &#x2F;&#x2F; 显示H，表示16进制表示数</span><br><span class="line">                 DigDisplay();                       &#x2F;&#x2F;引用数码管显示</span><br><span class="line">                &#125;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ReadIr() interrupt 0              &#x2F;&#x2F;外部中断函数定义，注意中断号</span><br><span class="line">&#123;</span><br><span class="line">                u8 j,k;          &#x2F;&#x2F;定义变量</span><br><span class="line">                u16 err;         </span><br><span class="line">                Time&#x3D;0;         &#x2F;&#x2F;时间变量                          </span><br><span class="line">                delay(700);                &#x2F;&#x2F;7ms  起始码</span><br><span class="line">                if(IRIN&#x3D;&#x3D;0)         &#x2F;&#x2F;确认是否真的接收到正确的信号</span><br><span class="line">                &#123;                 </span><br><span class="line">         </span><br><span class="line">         err&#x3D;1000;         &#x2F;&#x2F;1000*10us&#x3D;10ms,超过说明接收到错误的信号</span><br><span class="line"></span><br><span class="line">         while((IRIN&#x3D;&#x3D;0)&amp;&amp;(err&gt;0))                &#x2F;&#x2F;等待前面9ms的低电平过去           </span><br><span class="line">         &#123;                         </span><br><span class="line">                         delay(1);                   &#x2F;&#x2F;10us</span><br><span class="line">                         err--;             &#x2F;&#x2F;10us*1000&#x3D;10000us&#x3D;10ms</span><br><span class="line">         &#125; </span><br><span class="line">         if(IRIN&#x3D;&#x3D;1)                         &#x2F;&#x2F;如果正确等到9ms低电平</span><br><span class="line">         &#123;</span><br><span class="line">        err&#x3D;500;</span><br><span class="line">        while((IRIN&#x3D;&#x3D;1)&amp;&amp;(err&gt;0))    &#x2F;&#x2F;等待4.5ms的起始高电平过去</span><br><span class="line">        &#123;</span><br><span class="line">                delay(1);</span><br><span class="line">                 err--;            &#x2F;&#x2F;5ms 后强制退出</span><br><span class="line">                         &#125;</span><br><span class="line">                         for(k&#x3D;0;k&lt;4;k++)         &#x2F;&#x2F;共有4组数据  4个字节数据码</span><br><span class="line">                         &#123;         </span><br><span class="line">                for(j&#x3D;0;j&lt;8;j++)                &#x2F;&#x2F;接收一组数据 4*8&#x3D;32</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                         err&#x3D;60;         </span><br><span class="line">                         while((IRIN&#x3D;&#x3D;0)&amp;&amp;(err&gt;0))&#x2F;&#x2F;等待信号前面的560us低电平过去</span><br><span class="line">                         &#123;                       &#x2F;&#x2F;PPM脉冲调制方式</span><br><span class="line">                    delay(1);           &#x2F;&#x2F;10us</span><br><span class="line">                    err--;           &#x2F;&#x2F;60*10&#x3D;600us</span><br><span class="line">                         &#125;</span><br><span class="line">                             err&#x3D;500;</span><br><span class="line">                             while((IRIN&#x3D;&#x3D;1)&amp;&amp;(err&gt;0))                 &#x2F;&#x2F;计算高电平的时间长度。</span><br><span class="line">                         &#123;</span><br><span class="line">                   delay(10);                 &#x2F;&#x2F;0.1ms</span><br><span class="line">                   Time++;</span><br><span class="line">                   err--;</span><br><span class="line">                   if(Time&gt;30)                   &#x2F;&#x2F;若高电平时间超过3ms,强制退出（失败） 。</span><br><span class="line">                 &#123;</span><br><span class="line">                              return;</span><br><span class="line">                 &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                           IrValue[k]&gt;&gt;&#x3D;1;                    &#x2F;&#x2F;k表示第几组数据</span><br><span class="line">                           if(Time&gt;&#x3D;8)                         &#x2F;&#x2F;如果高电平出现大于565us，那么是1</span><br><span class="line">                          &#123;</span><br><span class="line">                   IrValue[k]|&#x3D;0x80;</span><br><span class="line">                          &#125;</span><br><span class="line">                            Time&#x3D;0;         &#x2F;&#x2F;用完时间要重新赋值                         </span><br><span class="line">                &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">              if(IrValue[2]!&#x3D;~IrValue[3])   &#x2F;&#x2F;验证数据码与数据反码，验证是否正确，错误就退出</span><br><span class="line">              &#123;</span><br><span class="line">                         return;</span><br><span class="line">              &#125;</span><br><span class="line">                      &#125;                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><ol><li>红外发送装置发出二进制脉冲码，程序里的是PPM码（脉冲位置调制码，脉冲串之间的时间间隔来实现信号调制）。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/11.png" title="图示">,可以看出：用户码或数据码中的每一个位可以是位 ‘1’ ，也可以是位 ‘0’。区分 ‘0’和 ‘1’是利用脉冲的时间间隔来区分，这种编码方式称为脉冲位置调制方式。</li><li>数据格式包括了引导码、用户码、数据码和数据码反码，编码总占32位。数据反码是数据码反相后的编码，编码时可用于对数据的纠错。注意：第二段的用户码也可以在遥控应用电路中被设置成第一段用户码的反码。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/12.png" title="图示"></li></ol><blockquote><p>所为遥控器其实是个红外发送装置，单片机上的为红外接受装置。发射装置已经完备封装在遥控器内，所以我们做的就是写红外接收的程序代码。</p></blockquote><p>根据遥控器上每个按键的二进制脉冲码的不同，可以设计很多小玩意，比如遥控器控制LED灯（我已经自己实践过，挺好玩！）。所以得知道每个按键的二进制脉冲码，根据上面的实验其实可以弄出来，这里给个总结的表格。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/13.png" title="图示"></p><table><tr><td>45H</td><td>46H</td><td>47H</td></tr><tr><td>44H</td><td>40H</td><td>43H</td></tr><tr><td>07H</td><td>15H</td><td>09H</td></tr><tr><td>16H</td><td>19H</td><td>0DH</td></tr><tr><td>0CH</td><td>18H</td><td>5EH</td></tr><tr><td>08H</td><td>1CH</td><td>5AH</td></tr><tr><td>42H</td><td>52H</td><td>4AH</td></tr></table><hr><h2 id="DS1302时钟"><a href="#DS1302时钟" class="headerlink" title="DS1302时钟"></a>DS1302时钟</h2><p>DS1302实时时钟具有能计算2100年之前的秒、分、时、日、日期、星期、月、年的能力，还有闰年调整的能力。<br>主函数main.c代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot;                </span><br><span class="line">#include &quot;ds1302.h&quot;                </span><br><span class="line"></span><br><span class="line">typedef unsigned int u16;                  </span><br><span class="line">typedef unsigned char u8;</span><br><span class="line"></span><br><span class="line">sbit LSA&#x3D;P2^2;              &#x2F;&#x2F;数码管38译码用</span><br><span class="line">sbit LSB&#x3D;P2^3;</span><br><span class="line">sbit LSC&#x3D;P2^4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char num&#x3D;0;</span><br><span class="line">u8 DisplayData[8];</span><br><span class="line">u8 code smgduan[10]&#x3D;&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;; &#x2F;&#x2F;显示数字0-9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay(u16 i)</span><br><span class="line">&#123;</span><br><span class="line">     while(i--);                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void datapros()         &#x2F;&#x2F;数据处理转换函数</span><br><span class="line">&#123;</span><br><span class="line">        Ds1302ReadTime();</span><br><span class="line">        DisplayData[0] &#x3D; smgduan[TIME[2]&#x2F;16];         &#x2F;&#x2F;时    </span><br><span class="line">        DisplayData[1] &#x3D; smgduan[TIME[2]&amp;0x0f];                 </span><br><span class="line">        DisplayData[2] &#x3D; 0x40;</span><br><span class="line">        DisplayData[3] &#x3D; smgduan[TIME[1]&#x2F;16];         &#x2F;&#x2F;分       </span><br><span class="line">        DisplayData[4] &#x3D; smgduan[TIME[1]&amp;0x0f];                </span><br><span class="line">        DisplayData[5] &#x3D; 0x40;</span><br><span class="line">        DisplayData[6] &#x3D; smgduan[TIME[0]&#x2F;16];         &#x2F;&#x2F;秒       </span><br><span class="line">        DisplayData[7] &#x3D; smgduan[TIME[0]&amp;0x0f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DigDisplay()         &#x2F;&#x2F;显示数码管</span><br><span class="line">&#123;</span><br><span class="line">        u8 i;</span><br><span class="line">        for(i&#x3D;0;i&lt;8;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        switch(i)                 </span><br><span class="line">        &#123;</span><br><span class="line">        case(0):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;1; break;</span><br><span class="line">        case(1):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;1; break;</span><br><span class="line">        case(2):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;1; break;</span><br><span class="line">        case(3):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;1; break;</span><br><span class="line">        case(4):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;1;LSC&#x3D;0; break;</span><br><span class="line">         case(5):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;1;LSC&#x3D;0; break;</span><br><span class="line">        case(6):</span><br><span class="line">        LSA&#x3D;1;LSB&#x3D;0;LSC&#x3D;0; break;</span><br><span class="line">        case(7):</span><br><span class="line">        LSA&#x3D;0;LSB&#x3D;0;LSC&#x3D;0; break;</span><br><span class="line">        &#125;</span><br><span class="line">        P0&#x3D;DisplayData[i];</span><br><span class="line">        delay(100); </span><br><span class="line">        P0&#x3D;0x00;</span><br><span class="line">        &#125;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;                </span><br><span class="line">        &#x2F;&#x2F;Ds1302Init();    &#x2F;&#x2F;第一次初始化后就可以注释该条语句，这样下次重启就不会再次初始化了       </span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        datapros();                </span><br><span class="line">        DigDisplay();                </span><br><span class="line">        &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块DS1302.c的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;ds1302.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;---DS1302写入和读取时分秒的地址命令---&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;---秒分时日月周年 最低位读写位;-------&#x2F;&#x2F;</span><br><span class="line">uchar code READ_RTC_ADDR[7] &#x3D; &#123;0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d&#125;; </span><br><span class="line">uchar code WRITE_RTC_ADDR[7] &#x3D; &#123;0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;---DS1302时钟初始化2016年5月7日星期六12点00分00秒。---&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;---存储顺序是秒分时日月周年,存储格式是用BCD码---&#x2F;&#x2F;</span><br><span class="line">uchar TIME[7] &#x3D; &#123;0, 0, 0x12, 0x07, 0x05, 0x06, 0x16&#125;;</span><br><span class="line"></span><br><span class="line">void Ds1302Write(uchar addr, uchar dat)   &#x2F;&#x2F;向DS1302命令（地址+数据）</span><br><span class="line">&#123;</span><br><span class="line">       uchar n;</span><br><span class="line">       RST &#x3D; 0;</span><br><span class="line">       _nop_();</span><br><span class="line"></span><br><span class="line">       SCLK &#x3D; 0;   &#x2F;&#x2F;先将SCLK置低电平。</span><br><span class="line">       _nop_();</span><br><span class="line">       RST &#x3D; 1;   &#x2F;&#x2F;然后将RST(CE)置高电平。</span><br><span class="line">       _nop_();</span><br><span class="line"></span><br><span class="line">       for (n&#x3D;0; n&lt;8; n++)       &#x2F;&#x2F;开始传送八位地址命令</span><br><span class="line">       &#123;</span><br><span class="line">       DSIO &#x3D; addr &amp; 0x01;   &#x2F;&#x2F;数据从低位开始传送</span><br><span class="line">       addr &gt;&gt;&#x3D; 1;</span><br><span class="line">       SCLK &#x3D; 1;      &#x2F;&#x2F;数据在上升沿时，DS1302读取数据</span><br><span class="line">       _nop_();</span><br><span class="line">       SCLK &#x3D; 0;</span><br><span class="line">       _nop_();</span><br><span class="line">       &#125;</span><br><span class="line">       for (n&#x3D;0; n&lt;8; n++)     &#x2F;&#x2F;写入8位数据</span><br><span class="line">       &#123;</span><br><span class="line">       DSIO &#x3D; dat &amp; 0x01;</span><br><span class="line">       dat &gt;&gt;&#x3D; 1;</span><br><span class="line">       SCLK &#x3D; 1;      &#x2F;&#x2F;数据在上升沿时，DS1302读取数据</span><br><span class="line">       _nop_();</span><br><span class="line">       SCLK &#x3D; 0;</span><br><span class="line">       _nop_();       </span><br><span class="line">       &#125;       </span><br><span class="line">        </span><br><span class="line">       RST &#x3D; 0;         &#x2F;&#x2F;传送数据结束</span><br><span class="line">       _nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uchar Ds1302Read(uchar addr)      &#x2F;&#x2F;读取一个地址的数据</span><br><span class="line">&#123;</span><br><span class="line">       uchar n,dat,dat1;</span><br><span class="line">       RST &#x3D; 0;</span><br><span class="line">       _nop_();</span><br><span class="line"></span><br><span class="line">       SCLK &#x3D; 0;           &#x2F;&#x2F;先将SCLK置低电平。</span><br><span class="line">       _nop_();</span><br><span class="line">       RST &#x3D; 1;               &#x2F;&#x2F;然后将RST(CE)置高电平。</span><br><span class="line">       _nop_();</span><br><span class="line"></span><br><span class="line">       for(n&#x3D;0; n&lt;8; n++)            &#x2F;&#x2F;开始传送八位地址命令</span><br><span class="line">       &#123;</span><br><span class="line">       DSIO &#x3D; addr &amp; 0x01;       &#x2F;&#x2F;数据从低位开始传送</span><br><span class="line">       addr &gt;&gt;&#x3D; 1;</span><br><span class="line">       SCLK &#x3D; 1;             &#x2F;&#x2F;数据在上升沿时，DS1302读取数据</span><br><span class="line">       _nop_();</span><br><span class="line">       SCLK &#x3D; 0;             &#x2F;&#x2F;DS1302下降沿时，放置数据</span><br><span class="line">       _nop_();</span><br><span class="line">       &#125;</span><br><span class="line">       _nop_();</span><br><span class="line">       for(n&#x3D;0; n&lt;8; n++)              &#x2F;&#x2F;读取8位数据</span><br><span class="line">       &#123;</span><br><span class="line">       dat1 &#x3D; DSIO;           &#x2F;&#x2F;从最低位开始接收</span><br><span class="line">       dat &#x3D; (dat&gt;&gt;1) | (dat1&lt;&lt;7);</span><br><span class="line">       SCLK &#x3D; 1;</span><br><span class="line">       _nop_();</span><br><span class="line">       SCLK &#x3D; 0;           &#x2F;&#x2F;DS1302下降沿时，放置数据</span><br><span class="line">       _nop_();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       RST &#x3D; 0;</span><br><span class="line">       _nop_();              &#x2F;&#x2F;以下为DS1302复位的稳定时间,必须的。</span><br><span class="line">       SCLK &#x3D; 1;</span><br><span class="line">       _nop_();</span><br><span class="line">       DSIO &#x3D; 0;</span><br><span class="line">       _nop_();</span><br><span class="line">       DSIO &#x3D; 1;</span><br><span class="line">       _nop_();</span><br><span class="line">       return dat;       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ds1302Init()         &#x2F;&#x2F;初始化DS1302</span><br><span class="line">&#123;</span><br><span class="line">       uchar n;</span><br><span class="line">       Ds1302Write(0x8E,0X00);        &#x2F;&#x2F;禁止写保护，就是关闭写保护功能</span><br><span class="line">       for (n&#x3D;0; n&lt;7; n++)           &#x2F;&#x2F;写入7个字节的时钟信号：分秒时日月周年</span><br><span class="line">       &#123;</span><br><span class="line">       Ds1302Write(WRITE_RTC_ADDR[n],TIME[n]);       </span><br><span class="line">       &#125;</span><br><span class="line">       Ds1302Write(0x8E,0x80);        &#x2F;&#x2F;打开写保护功能</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Ds1302ReadTime()             &#x2F;&#x2F;读取时钟信息</span><br><span class="line">&#123;</span><br><span class="line">       uchar n;</span><br><span class="line">       for (n&#x3D;0; n&lt;7; n++)      &#x2F;&#x2F;读取7个字节的时钟信号：分秒时日月周年</span><br><span class="line">       &#123;</span><br><span class="line">       TIME[n] &#x3D; Ds1302Read(READ_RTC_ADDR[n]);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件DS1302.h代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef __DS1302_H_</span><br><span class="line">#define __DS1302_H_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;reg52.h&gt;     &#x2F;&#x2F;头文件</span><br><span class="line">#include&lt;intrins.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef uchar          &#x2F;&#x2F;重定义关键词</span><br><span class="line">#define uchar unsigned char</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef uint </span><br><span class="line">#define uint unsigned int</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">sbit DSIO&#x3D;P3^4;</span><br><span class="line">sbit RST&#x3D;P3^5;</span><br><span class="line">sbit SCLK&#x3D;P3^6;</span><br><span class="line"></span><br><span class="line">void Ds1302Write(uchar addr, uchar dat);</span><br><span class="line">uchar Ds1302Read(uchar addr);</span><br><span class="line">void Ds1302Init();</span><br><span class="line">void Ds1302ReadTime();</span><br><span class="line"></span><br><span class="line">extern uchar TIME[7];       &#x2F;&#x2F;加入全局变量</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>读写时序原理图：</p></blockquote><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA2/14.png" title="图示"><blockquote><p>DS1302寄存器和RAM：<br></p></blockquote><p>1．控制寄存器</p><table><tr><td>D7</td><td>D6</td><td>D5</td><td>D4</td><td>D3</td><td>D2</td><td>D1</td><td>D0</td></tr><tr><td>1</td><td>RAM/CK</td><td>A4</td><td>A3</td><td>A2</td><td>A1</td><td>A0</td><td>RD/W</td></tr></table><p>D7：固定为1<br><br>D6：RAM/CK位，=1片内RAM，=0日历、时钟寄存器选择位。<br><br>D5~D1：地址位，用于选择进行读写的日历、时钟寄存器或片内RAM。对日历、时钟寄存器或片内RAM的选择见表。<br><br>D0： 读写选择，=0写，=1读<br></p><blockquote><p>还有时钟日期寄存器，比较多，可以自己搜。</p></blockquote><hr>]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>初学单片机的障碍</title>
    <url>/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<h2 id="丛书推荐-我没怎么看"><a href="#丛书推荐-我没怎么看" class="headerlink" title="丛书推荐(我没怎么看)"></a>丛书推荐(我没怎么看)</h2><p>这本书的内容大多是仿真内容。（如果想直接附带实践的学习在后面有资料推荐）<a id="more"></a></p><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/0.jpg" title="图示"><br>由于疫情原因，资金不足，买的二手书，有些许笔记也不错。<p>单片机开发板可以选择51单片机stc89c52开发板</p><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/1.jpg" title="图示"><br>四五十块钱就行了，也不需要买的太全。<hr><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p>如果手头买了单片机的，比如上面的STC89c52单片机，单片机里面有二维码，里面有百度云资料下载，根据单片机板右下角的型号如图<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/4.jpg" title="图示">选择资料下载。内涵丰富的视频资源以及完整的系统图。（视频真的超赞的，目前还在跟着学习。）<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/5.jpg" title="图示"></p><hr><h2 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h2><p>单片机学习需要的Keil开发环境和Proteus仿真软件，书上推荐的是Keil4和Proteus7.10，但由于下载的时候Proteus7.10元件库的缺失，最后我下载的是Proteus7.8，差不太多。<br>下载地址选择微信公众号–软件安装管家–软件目录<br></p><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/2.jpg" title="图示"><img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/3.jpg" title="图示"><br><p>软件管家上面有网盘下载资料和丰富的安装过程，如遇问题个别搜资料可解决。</p><hr><h2 id="keil4的编译-目标未创建"><a href="#keil4的编译-目标未创建" class="headerlink" title="keil4的编译-目标未创建"></a>keil4的编译-目标未创建</h2><p>首先讲一下自己碰到的问题，在编译语言后出现<br></p><blockquote><p>— Error: failed to execute ‘d:\Keil\51单片机\BIN\C51.EXE’<br></p></blockquote><!-- more --><p>一开始百思不得其解，网上很多方法也不适用，后来注意到错误的路径，因为当初害怕中文存储的路径会有影响，所以在下载安装完成之后将存在D盘中的 /51单片机/ 改成了 /51dpj/ ，这也是问题所在。<br>解决措施：<br></p><blockquote><p>找到自己的keil安装目录，下面有个TOOLS.INI文件。用记事本打开这个文件，找到：[C51] PATH=”d:\Keil\C51”或类似字样，将PATH=后面的内容改为自己keil实际安装的目录，最后一个文件夹是C51。我把\51单片机\换成实际路径\51dpj\就好了，其他的不需要动。然后保存TOOLS.INI。重启keil即可生效（务必要重启keil）。</p></blockquote><hr><h2 id="烧入不成功的可能原因"><a href="#烧入不成功的可能原因" class="headerlink" title="烧入不成功的可能原因"></a>烧入不成功的可能原因</h2><p>1.如果选好文件后点击 “程序下载” 出现烧入不成功，如<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/7.jpg" title="图示"><br>,这里不是什么网上所说的什么波特率太高，你尝试一下把芯片类型从STC89Cxx Series改成STC89Cxx (NEW)<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/8.jpg" title="图示"><br>然后再点“程序下载”，就可以了。上图包含了下载成功后的内容。<br>2.程序正确，将波特率调低再度尝试。</p><hr><h2 id="流水灯代码build失败"><a href="#流水灯代码build失败" class="headerlink" title="流水灯代码build失败"></a>流水灯代码build失败</h2><p>切记注意头文件的引入，左移右移需要引入<code>#include &quot;intrins.h&quot;</code>的头文件。</p><hr><h2 id="串口通信无法下载程序以及数据显示乱码"><a href="#串口通信无法下载程序以及数据显示乱码" class="headerlink" title="串口通信无法下载程序以及数据显示乱码"></a>串口通信无法下载程序以及数据显示乱码</h2><p>在串口通信章节，用到串口调试助手发送数据，再由单片机接收再返回显示。在发送数据时，有时候会出现乱码，这里是因为UTX和URX之间的互通受影响。需要将单片机上UTX与URX短接，P3.0与P3.1也是。如图。<img src="/%E5%88%9D%E5%AD%A6%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E9%9A%9C%E7%A2%8D/9.jpg" title="图示">.<br>但是在还没下载程序前，下载程序时，需要将UTX连接P3.0，URX连接P3.1。不然会下载不成功。</p>]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title>申请域名后的一些问题（持续更新）</title>
    <url>/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E5%90%8E%E7%9A%84%E4%BA%9B%E8%AE%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="针对域名后问题"><a href="#针对域名后问题" class="headerlink" title="针对域名后问题"></a>针对域名后问题</h1><a id="more"></a><p>因为觉得本身.github.io的后缀不好，而去购买域名，这是一个好事，但是也会在后面暴露一些问题。</p><h2 id="关于域名如何与GitHub相连"><a href="#关于域名如何与GitHub相连" class="headerlink" title="关于域名如何与GitHub相连"></a>关于域名如何与GitHub相连</h2><p>基本可以参考大佬的博客<br>例如：<a href="https://blog.csdn.net/u012733501/article/details/104841734?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3" target="_blank" rel="noopener">易01的CSDN博客</a></p><h2 id="CNAME的构建"><a href="#CNAME的构建" class="headerlink" title="CNAME的构建"></a>CNAME的构建</h2><p>一开始我在参考大佬的博客时，一直被这个问题困扰（可能是我无知），大佬们说要一个无后缀的CNAME文件，内容为你申请的域名如cjl520.top。<br>用Win10的必须打开我的电脑-查看-打开文件扩展名</p><img src="/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E5%90%8E%E7%9A%84%E4%BA%9B%E8%AE%B8%E9%97%AE%E9%A2%98/1.png" title="图示"><br><p>然后在你Blog跟目下找source文件夹，创建一个TXT文档，在里面写好域名cjl520.top，然后点击另存为，格式选所有类型，名字改为CNAME即可。（这是一个无后缀文件，电脑上一般打不开）</p><img src="/%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E5%90%8E%E7%9A%84%E4%BA%9B%E8%AE%B8%E9%97%AE%E9%A2%98/2.png" title="图示">]]></content>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Blog文章的编写（持续更新）"><a href="#Blog文章的编写（持续更新）" class="headerlink" title="Blog文章的编写（持续更新）"></a>Blog文章的编写（持续更新）</h1><h2 id="构建md"><a href="#构建md" class="headerlink" title="构建md"></a>构建md</h2><p>在主目录Blog中打开Git Bush here<br>输入</p><blockquote><pre><code>hexo new &quot;你文章的主题&quot;</code></pre></blockquote><a id="more"></a><p>然后就会帮你在\blog\source_posts\你的文章主题.md</p><h2 id="写标题"><a href="#写标题" class="headerlink" title="写标题"></a>写标题</h2><p>使用标题时需要#键<br>#一级标题<br>##二级标题<br>###三级标题<br>….<br>######六级标题</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>第一个段落</p><p>第二个段落</p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><blockquote><p>这是一引用段落，将会被高亮显示（研究一下如何使他背景变黑）</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>代码如下</p><blockquote><pre><code>[百度](https://www.baidu.com/index.php?tn=98010089_dg_pg&amp;ch=11)</code></pre></blockquote><p><a href="https://www.baidu.com/index.php?tn=98010089_dg_pg&ch=11" target="_blank" rel="noopener">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>代码如下</p><blockquote><pre><code>![卡通](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=250831898,1018562677&amp;fm=26&amp;gp=0.jpg) </code></pre></blockquote><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=250831898,1018562677&fm=26&gp=0.jpg" alt="卡通"></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>代码如下</p><blockquote><pre><code>* 无序列表项</code></pre></blockquote><ul><li>无序列表项</li><li>无序列表项</li><li>无序列表项<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2></li></ul><ol><li>有序列表项1</li><li>有序列表项2</li><li>有序列表项3<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2>三条及以上的-或者*<blockquote><pre><code> --- 
*** </code></pre></blockquote></li></ol><hr><hr><hr><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>代码如下</p><blockquote><pre><code>表头|表头|表头
---|:---:|---:
内容|内容|内容
内容|内容|内容</code></pre></blockquote><p>有时候无法显示正确<br>可以用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;USB-TTL&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;ESP8266-01S&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;3.3V&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;VCC&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;GND&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;GND&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;RX&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;TX&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;TX&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;RX&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;3.3V&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;CH_PD(EN)&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>注意点</p><ol><li>默认都靠左，两边都有冒号居中<table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table></li></ol><h2 id="回车"><a href="#回车" class="headerlink" title="回车"></a>回车</h2><p>在文字后面加<br><br><code>&lt;br/&gt;</code><br>就会自动帮你回车。</p><h2 id="markdown可视化编辑"><a href="#markdown可视化编辑" class="headerlink" title="markdown可视化编辑"></a>markdown可视化编辑</h2><p>先按Ctrl+k，然后点一下v，就可以了<br>效果如下<br><img src="/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/1.png" title="图示"></p>]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<h1 id="文章省略？"><a href="#文章省略？" class="headerlink" title="文章省略？"></a>文章省略？</h1><a id="more"></a><h2 id="这是个介绍，索性给我实验"><a href="#这是个介绍，索性给我实验" class="headerlink" title="这是个介绍，索性给我实验"></a>这是个介绍，索性给我实验</h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>非常的激动，搭载好了自己的博客，花了几天时间去各个大佬博客搜资料以及在b站观察大佬们的制作视频，虽然自己仍是技术方面的萌新选手，但我相信，我今天所为会比昨天的自己更加优秀，索性就研究下怎么添加一个签名去吧。封面除了沙雕的内容其他全部保留用来纪念以及敬畏。</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
