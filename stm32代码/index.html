<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>stm32代码 | cjl's Blog</title><meta name="description" content="简介stm32的寄存器和外设的学习难度比51有了太大的提升，目前也仍在学习当中，在此就仿照当初51的学习过程将关键的代码写下，方便日后直接使用和查看。自己也是入手一个原子的mini板子，在教程和各种资料下努力挣扎。冲！！！GPIO的知识IO口输入输出模式4种输入模式：输入浮空；输入上拉；输入下拉；模拟输入；4种输出模式：开漏输出；开漏复用功能；推挽式输出；推挽式复用功能；3种最大输出速度：2MHZ"><meta name="keywords" content="stm32"><meta name="author" content="Dragon6879"><meta name="copyright" content="Dragon6879"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://cjl520.top/stm32%E4%BB%A3%E7%A0%81/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta property="og:type" content="article"><meta property="og:title" content="stm32代码"><meta property="og:url" content="http://cjl520.top/stm32%E4%BB%A3%E7%A0%81/"><meta property="og:site_name" content="cjl's Blog"><meta property="og:description" content="简介stm32的寄存器和外设的学习难度比51有了太大的提升，目前也仍在学习当中，在此就仿照当初51的学习过程将关键的代码写下，方便日后直接使用和查看。自己也是入手一个原子的mini板子，在教程和各种资料下努力挣扎。冲！！！GPIO的知识IO口输入输出模式4种输入模式：输入浮空；输入上拉；输入下拉；模拟输入；4种输出模式：开漏输出；开漏复用功能；推挽式输出；推挽式复用功能；3种最大输出速度：2MHZ"><meta property="og:image" content="http://cjl520.top/img/5.jpg"><meta property="article:published_time" content="2020-07-18T08:47:40.000Z"><meta property="article:modified_time" content="2020-08-13T11:44:42.056Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG={root:"/",hexoversion:"4.2.0",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},bookmark:{message_prev:"按",message_next:"键将本页加入书签"},runtime_unit:"天",runtime:!1,copyright:void 0,ClickShowText:{text:"I,LOVE,YOU",fontSize:"15px"},medium_zoom:!1,fancybox:!0,Snackbar:void 0,justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},baiduPush:!1,highlightCopy:!0,highlightLang:!0,isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isSidebar:!0,postUpdate:"2020-08-13 19:44:42"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/touxiang.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPIO的知识"><span class="toc-number">1.1.</span> <span class="toc-text">GPIO的知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跑马灯实验"><span class="toc-number">1.2.</span> <span class="toc-text">跑马灯实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按键实验"><span class="toc-number">1.3.</span> <span class="toc-text">按键实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串口通信"><span class="toc-number">1.4.</span> <span class="toc-text">串口通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#外部中断（按键）"><span class="toc-number">1.5.</span> <span class="toc-text">外部中断（按键）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#独立看门狗"><span class="toc-number">1.6.</span> <span class="toc-text">独立看门狗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stm32通用定时器"><span class="toc-number">1.7.</span> <span class="toc-text">stm32通用定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM脉宽调制"><span class="toc-number">1.8.</span> <span class="toc-text">PWM脉宽调制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OLED显示"><span class="toc-number">1.9.</span> <span class="toc-text">OLED显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TFTLCD显示"><span class="toc-number">1.10.</span> <span class="toc-text">TFTLCD显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC实验"><span class="toc-number">1.11.</span> <span class="toc-text">ADC实验</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(/img/5.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">cjl's Blog</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">stm32代码</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-18T08:47:40.000Z" title="发表于 2020-07-18 16:47:40">2020-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-13T11:44:42.056Z" title="更新于 2020-08-13 19:44:42">2020-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8D%95%E7%89%87%E6%9C%BA/">单片机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/stm32%E4%BB%A3%E7%A0%81/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/stm32%E4%BB%A3%E7%A0%81/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>stm32的寄存器和外设的学习难度比51有了太大的提升，目前也仍在学习当中，在此就仿照当初51的学习过程将关键的代码写下，方便日后直接使用和查看。<a id="more"></a>自己也是入手一个原子的mini板子，在教程和各种资料下努力挣扎。冲！！！<br></p><hr><h2 id="GPIO的知识"><a href="#GPIO的知识" class="headerlink" title="GPIO的知识"></a>GPIO的知识</h2><blockquote><p>IO口输入输出模式</p></blockquote><ol><li>4种输入模式：<br>输入浮空；<br>输入上拉；<br>输入下拉；<br>模拟输入；</li><li>4种输出模式：<br>开漏输出；<br>开漏复用功能；<br>推挽式输出；<br>推挽式复用功能；</li><li>3种最大输出速度：<br>2MHZ；<br>10MHz；<br>50MHz；<blockquote><p>每组IO口所含7个寄存器</p></blockquote></li><li>GPIOx_CRL :端口配置低寄存器</li><li>GPIOx_CRH:端口配置高寄存器</li><li>GPIOx_IDR:端口输入寄存器</li><li>GPIOx_ODR:端口输出寄存器</li><li>GPIOx_BSRR:端口位设置/清除寄存器</li><li>GPIOx_BRR :端口位清除寄存器</li><li>GPIOx_LCKR:端口配置锁存寄存器</li></ol><hr><h2 id="跑马灯实验"><a href="#跑马灯实验" class="headerlink" title="跑马灯实验"></a>跑马灯实验</h2><p>mini板子上的两个LED灯的控制（一红一绿）。<br><br>首先是led.c的使能代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LED.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span>     <span class="comment">//任意源文件只要包含了stm32f10x.h，就可以在源文件调用任意外设的函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;  <span class="comment">//声明一个结构体 </span></span><br><span class="line">     </span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOD, ENABLE);          <span class="comment">//使能 GPIOA,GPIOD 端口时钟(每个实验都要使能时钟)</span></span><br><span class="line">     </span><br><span class="line">    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;   <span class="comment">//设置推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin= GPIO_Pin_8;         <span class="comment">//配置PA8引脚LED0</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;  <span class="comment">//IO 口速度为 50MHz</span></span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);           <span class="comment">//初始化GPIOA.8</span></span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_8);                 <span class="comment">//拉高（不亮）</span></span><br><span class="line">     </span><br><span class="line">    GPIO_InitStructure.GPIO_Pin= GPIO_Pin_2;      <span class="comment">//配置PD2引脚LED1</span></span><br><span class="line">    GPIO_Init(GPIOD,&amp;GPIO_InitStructure);         <span class="comment">//初始化GPIOD.2</span></span><br><span class="line">    GPIO_SetBits(GPIOD,GPIO_Pin_2);              <span class="comment">//拉高（不亮）</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>led.h头文件的代码（这个都要会写）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>   <span class="comment">//引脚IO口的头文件调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED0 PAout(8) <span class="comment">// PA8   位操作PAout(8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED1 PDout(2) <span class="comment">// PD2</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c主函数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span>   <span class="comment">//调用外设</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span>         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span>      <span class="comment">//延时函数的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      </span><br><span class="line">      delay_init();    <span class="comment">//延时函数初始化</span></span><br><span class="line"></span><br><span class="line">      LED_Init();      <span class="comment">//led的初始化</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="comment">//注释掉的是库函数操作的调用拉高函数</span></span><br><span class="line">      <span class="comment">//GPIO_SetBits(GPIOA,GPIO_Pin_8);</span></span><br><span class="line">      <span class="comment">//GPIO_SetBits(GPIOD,GPIO_Pin_2);</span></span><br><span class="line">      <span class="comment">//LED0直接赋值拉高是因为宏定义过LED0为PAout(8)</span></span><br><span class="line">      <span class="comment">//这是位带操作直接赋值到寄存器的方式</span></span><br><span class="line">      LED0=<span class="number">1</span>;</span><br><span class="line">      LED1=<span class="number">0</span>;</span><br><span class="line">      delay_ms(<span class="number">500</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//GPIO_ResetBits(GPIOA,GPIO_Pin_8);</span></span><br><span class="line">      <span class="comment">//GPIO_ResetBits(GPIOD,GPIO_Pin_2);</span></span><br><span class="line">      LED0=<span class="number">0</span>;</span><br><span class="line">      LED1=<span class="number">1</span>;</span><br><span class="line">      delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//还有一种直接操纵寄存器的(我没试，应该没问题)</span></span><br><span class="line">      <span class="comment">//GPIOA-&gt;BRR=GPIO_Pin_8; //设置 GPIOA.8 输出 1,等同 LED0=1;</span></span><br><span class="line">      <span class="comment">//GPIOA-&gt;BSRR=GPIO_Pin_8; //设置 GPIOA.8 输出 0,等同 LED0=0;</span></span><br><span class="line">           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每个.c或者.h文件敲完后要回车留一空行，不然编译会出错（听说书软件的BUG）。有条件的可以自己买个便宜的（不用买配套的）ST-LINK下载器，用着也没什么问题。比ISP下载方便多了，敲完代码就可以下载。</p></blockquote><hr><h2 id="按键实验"><a href="#按键实验" class="headerlink" title="按键实验"></a>按键实验</h2><p>按键key.c文件代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      </span><br><span class="line">      GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC,ENABLE);<span class="comment">//使能PORTA,PORTC时钟</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);//关闭jtag，使能SWD，可以用SWD模式调试</span></span><br><span class="line">      </span><br><span class="line">      GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_15;<span class="comment">//PA15</span></span><br><span class="line">      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//设置成上拉输入</span></span><br><span class="line">       GPIO_Init(GPIOA, &amp;GPIO_InitStructure);   <span class="comment">//初始化GPIOA15</span></span><br><span class="line">      </span><br><span class="line">      GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_5;  <span class="comment">//PC5</span></span><br><span class="line">      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; <span class="comment">//设置成上拉输入</span></span><br><span class="line">       GPIO_Init(GPIOC, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOC5</span></span><br><span class="line"> </span><br><span class="line">      GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;<span class="comment">//PA0</span></span><br><span class="line">      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; <span class="comment">//PA0设置成输入，默认下拉        </span></span><br><span class="line">      GPIO_Init(GPIOA, &amp;GPIO_InitStructure);<span class="comment">//初始化GPIOA.0</span></span><br><span class="line">      </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">      <span class="keyword">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键按松开标志</span></span><br><span class="line">      <span class="keyword">if</span>(mode)key_up=<span class="number">1</span>;  <span class="comment">//支持连按  ,mode=0,不支持连续按（自己试试）      </span></span><br><span class="line">      <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))<span class="comment">//看按键的硬件图</span></span><br><span class="line">      &#123;</span><br><span class="line">      delay_ms(<span class="number">10</span>);  <span class="comment">//去抖动 </span></span><br><span class="line">      key_up=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(KEY0==<span class="number">0</span>)<span class="keyword">return</span> KEY0_PRES;  <span class="comment">//按下</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>)<span class="keyword">return</span> KEY1_PRES;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>)<span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>; <span class="comment">//无按键按下           </span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按键key.h头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KEY_H         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0  GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_5)<span class="comment">//读取按键0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1  GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_15)<span class="comment">//读取按键1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WK_UP   GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)<span class="comment">//读取按键2 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_PRES        1        <span class="comment">//KEY0  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY1_PRES        2        <span class="comment">//KEY1 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WKUP_PRES        3        <span class="comment">//WK_UP</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KEY_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;    <span class="comment">//IO初始化</span></span><br><span class="line"><span class="function">u8 <span class="title">KEY_Scan</span><span class="params">(u8 mode)</span></span>;          <span class="comment">//按键扫描函数            </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主函数main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"key.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;        </span><br><span class="line">        u8 t=<span class="number">0</span>;          </span><br><span class="line">        delay_init();          <span class="comment">//延时函数初始化          </span></span><br><span class="line">        LED_Init();            <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">        KEY_Init();          <span class="comment">//初始化与按键连接的硬件接口</span></span><br><span class="line">        LED0=<span class="number">0</span>;             <span class="comment">//点亮LED</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        t=KEY_Scan(<span class="number">0</span>);        <span class="comment">//得到键值</span></span><br><span class="line">        <span class="keyword">switch</span>(t)</span><br><span class="line">        &#123;         </span><br><span class="line">        <span class="keyword">case</span> KEY0_PRES:</span><br><span class="line">        LED0=!LED0;         <span class="comment">//改变状态</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY1_PRES:</span><br><span class="line">        LED1=!LED1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WKUP_PRES:        </span><br><span class="line">        LED0=!LED0;</span><br><span class="line">        LED1=!LED1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        delay_ms(<span class="number">10</span>);        </span><br><span class="line">        &#125; </span><br><span class="line">        &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初始化跟跑马灯的一样不难，看手册和PPT可以理解。led的.c文件和头文件仍是需要的，在点灯基础上才能进行，不然程序里哪来的引用。</p></blockquote><hr><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p>与51单片机的串口通信相似，也是通过串口连接单片机接收发送的数据。<br>因为库函数中自带的usart.c文件中完整的文件，这里我直接按照视频中做最基础的部分（不含接收状态的判断等）。<br>main.c文件代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_USART1_Init</span><span class="params">(u32 bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     GPIO_InitTypeDef GPIO_InitStrue;   <span class="comment">//结构体</span></span><br><span class="line">     USART_InitTypeDef USART_InitStrue;</span><br><span class="line">     NVIC_InitTypeDef NVIC_InitStrue;</span><br><span class="line">     </span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<span class="comment">//</span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);<span class="comment">//使能时钟A和串口一</span></span><br><span class="line">     </span><br><span class="line">     GPIO_InitStrue.GPIO_Mode=GPIO_Mode_AF_PP;   <span class="comment">//GPIO端口模式配置</span></span><br><span class="line">     GPIO_InitStrue.GPIO_Pin=GPIO_Pin_9;             <span class="comment">//复用推挽</span></span><br><span class="line">     GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;     </span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStrue);<span class="comment">//②        //初始化</span></span><br><span class="line">     </span><br><span class="line">     GPIO_InitStrue.GPIO_Mode=GPIO_Mode_IN_FLOATING;  <span class="comment">//串口一初始化</span></span><br><span class="line">     GPIO_InitStrue.GPIO_Pin=GPIO_Pin_10;      </span><br><span class="line">     GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStrue);<span class="comment">//②</span></span><br><span class="line">     <span class="comment">//串口参数初始化</span></span><br><span class="line">     USART_InitStrue.USART_BaudRate=bound;     <span class="comment">//波特率     </span></span><br><span class="line">     USART_InitStrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;<span class="comment">//无硬件数据流控制</span></span><br><span class="line">     USART_InitStrue.USART_Mode=USART_Mode_Tx|USART_Mode_Rx;<span class="comment">//收发模式</span></span><br><span class="line">     USART_InitStrue.USART_Parity=USART_Parity_No;<span class="comment">//无奇偶校验位</span></span><br><span class="line">     USART_InitStrue.USART_StopBits=USART_StopBits_1;<span class="comment">//一个停止位</span></span><br><span class="line">     USART_InitStrue.USART_WordLength=USART_WordLength_8b; <span class="comment">//字长为 8 位</span></span><br><span class="line">     </span><br><span class="line">     USART_Init(USART1,&amp;USART_InitStrue);<span class="comment">//③串口参数初始化</span></span><br><span class="line">     </span><br><span class="line">     USART_Cmd(USART1,ENABLE);<span class="comment">//使能串口1</span></span><br><span class="line">     </span><br><span class="line">     USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);<span class="comment">//开启接收中断</span></span><br><span class="line">     </span><br><span class="line">     NVIC_InitStrue.NVIC_IRQChannel=USART1_IRQn; <span class="comment">//串口通道</span></span><br><span class="line">     NVIC_InitStrue.NVIC_IRQChannelCmd=ENABLE;   <span class="comment">//IRQ 通道使能</span></span><br><span class="line">     NVIC_InitStrue.NVIC_IRQChannelPreemptionPriority=<span class="number">3</span>;<span class="comment">//抢占优先级 3</span></span><br><span class="line">     NVIC_InitStrue.NVIC_IRQChannelSubPriority=<span class="number">3</span>;<span class="comment">//子优先级 3</span></span><br><span class="line">     NVIC_Init(&amp;NVIC_InitStrue);       <span class="comment">//中断优先级初始化</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>   <span class="comment">//编写中断处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      u8 res;</span><br><span class="line">      <span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE))<span class="comment">//RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并且可以读出来了。</span></span><br><span class="line"> &#123;</span><br><span class="line">     res= USART_ReceiveData(USART1); <span class="comment">//接收数据，从DR接收到的数据</span></span><br><span class="line">     USART_SendData(USART1,res);   <span class="comment">//发送到串口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;     </span><br><span class="line">     My_USART1_Init(<span class="number">9600</span>);          <span class="comment">//调用初始化函数</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">//设置中断分组（优先级0-3）</span></span><br><span class="line">     delay_init();</span><br><span class="line">     LED_Init();</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;   </span><br><span class="line">          LED1 =!LED1 ;</span><br><span class="line">          delay_ms(<span class="number">500</span>);</span><br><span class="line">      &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实验现象就是串口调试助手中，你发送一个数据，显示你发送的数据。（死循环中的灯随便加的）。</p><hr><h2 id="外部中断（按键）"><a href="#外部中断（按键）" class="headerlink" title="外部中断（按键）"></a>外部中断（按键）</h2><p>STM32的每个IO口都有中断。<br>exti.c中断代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"exti.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usart.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部中断初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTIX_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">        EXTI_InitTypeDef EXTI_InitStructure;<span class="comment">//结构体</span></span><br><span class="line">        NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">         RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<span class="comment">//外部中断，需要使能AFIO时钟</span></span><br><span class="line"></span><br><span class="line">       KEY_Init();<span class="comment">//初始化按键对应io模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOC.5 中断线以及中断初始化配置，映射到中断线上</span></span><br><span class="line">       GPIO_EXTILineConfig(GPIO_PortSourceGPIOC,GPIO_PinSource5);<span class="comment">//每个IO口都有中断，0-15中断线</span></span><br><span class="line"></span><br><span class="line">       EXTI_InitStructure.EXTI_Line=EXTI_Line5;<span class="comment">//指定配置的中断线</span></span><br><span class="line">       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     <span class="comment">//中断模式</span></span><br><span class="line">       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发</span></span><br><span class="line">       EXTI_InitStructure.EXTI_LineCmd = ENABLE;<span class="comment">//cmd使能</span></span><br><span class="line">       EXTI_Init(&amp;EXTI_InitStructure);           <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOA.15       中断线以及中断初始化配置</span></span><br><span class="line">       GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource15);</span><br><span class="line"></span><br><span class="line">       EXTI_InitStructure.EXTI_Line=EXTI_Line15;</span><br><span class="line">       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     </span><br><span class="line">       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">       EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">       EXTI_Init(&amp;EXTI_InitStructure);            <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIOA.0       中断线以及中断初始化配置</span></span><br><span class="line">       GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0);</span><br><span class="line"></span><br><span class="line">        EXTI_InitStructure.EXTI_Line=EXTI_Line0;</span><br><span class="line">       EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;     </span><br><span class="line">       EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;</span><br><span class="line">       EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">       EXTI_Init(&amp;EXTI_InitStructure);          <span class="comment">//根据EXTI_InitStruct中指定的参数初始化外设EXTI寄存器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//配置中断分组，使能中断                                        //在stm32f10x.h中，中断通道对应的线</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;               <span class="comment">//使能按键所在的外部中断通道</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;     <span class="comment">//抢占优先级2 misc.h中</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;               <span class="comment">//子优先级1</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                         <span class="comment">//使能外部中断通道</span></span><br><span class="line">       NVIC_Init(&amp;NVIC_InitStructure);         <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line">          </span><br><span class="line">          NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;               <span class="comment">//使能按键所在的外部中断通道（中断线5-9的中断通道）</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;     <span class="comment">//抢占优先级2， </span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;               <span class="comment">//子优先级1</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                         <span class="comment">//使能外部中断通道</span></span><br><span class="line">       NVIC_Init(&amp;NVIC_InitStructure); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;               <span class="comment">//使能按键所在的外部中断通道（中断线10-15的中断通道）</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;     <span class="comment">//抢占优先级2， </span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;               <span class="comment">//子优先级1</span></span><br><span class="line">       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;                         <span class="comment">//使能外部中断通道</span></span><br><span class="line">       NVIC_Init(&amp;NVIC_InitStructure); </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断发生处理的函数（触发）</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>   <span class="comment">//编写中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  delay_ms(<span class="number">10</span>);    <span class="comment">//消抖</span></span><br><span class="line">     <span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">     &#123;       </span><br><span class="line">          LED0=!LED0;</span><br><span class="line">          LED1=!LED1;     </span><br><span class="line">     &#125;</span><br><span class="line">     EXTI_ClearITPendingBit(EXTI_Line0);  <span class="comment">//手动清除EXTI0线路挂起位，不然下次不会触发</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">EXTI9_5_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;               </span><br><span class="line">     delay_ms(<span class="number">10</span>);   <span class="comment">//消抖                </span></span><br><span class="line">     <span class="keyword">if</span>(KEY0==<span class="number">0</span>)     &#123;</span><br><span class="line">          LED0=!LED0;</span><br><span class="line">     &#125;</span><br><span class="line">       EXTI_ClearITPendingBit(EXTI_Line5);    <span class="comment">//清除LINE5上的中断标志位  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI15_10_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  delay_ms(<span class="number">10</span>);    <span class="comment">//消抖                </span></span><br><span class="line">  <span class="keyword">if</span>(KEY1==<span class="number">0</span>)     &#123;</span><br><span class="line">          LED1=!LED1;</span><br><span class="line">     &#125;</span><br><span class="line">      EXTI_ClearITPendingBit(EXTI_Line15);  <span class="comment">//清除LINE15线路挂起位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数自己会写。（感觉自己现在进步了一丢丢，O(∩_∩)O哈哈~）。如果你在循环中写点东西，中断发生的时候处理中断函数，然后再发生循环里的函数。这就是中断。</p><hr><h2 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h2><p>啥是看门狗？很难一下子说清，我的理解就是stm32板子上一个独立的时钟区域，可以独立运行，在板子程序受到外界干扰跑飞的时候，它可以独立运行并判断，并及时复位。</p><blockquote><p>独立看门狗与窗口看门狗最大不同的地方在计数，独立看门狗通过键值寄存<br>器（IWDG_KR），写入0xCCCC，开始启用独立看门狗；此时计数器开始从其复位值0xFFF递减计数。当计数器计数到末尾0x000时，会产生一个复位信号(IWDG_RESET)。无论何时，只要键寄存器 IWDG_KR 中被写入0xAAAA， IWDG_RLR 中的值就会被重新加载到计数器中从而避免产生看门狗复位（这就是喂狗操作）。<br>iwdg.c独立看门狗初始化代码：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iwdg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Init</span><span class="params">(u8 prer,u16 rlr)</span> <span class="comment">//初始化函数，参数是为了方便调节</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">     <span class="comment">//取消寄存器写保护（向 IWDG_KR 写入 0X5555），通过寻址发现IWDG_WriteAccess_Enable就是0X5555（define操作）</span></span><br><span class="line">     IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);  <span class="comment">//使能对寄存器IWDG_PR和IWDG_RLR的写操作</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//看门狗溢出时间：Tout=((4× 2^prer) × rlr) /40</span></span><br><span class="line">     <span class="comment">//prer 为看门狗时钟预分频值（IWDG_PR 值），范围为 0~7； rlr 为看门狗的重装载值（IWDG_RLR 的值）；</span></span><br><span class="line"></span><br><span class="line">    IWDG_SetPrescaler(prer);  <span class="comment">//设置IWDG预分频值:设置IWDG预分频值为64</span></span><br><span class="line">    </span><br><span class="line">    IWDG_SetReload(rlr);  <span class="comment">//设置IWDG重装载值</span></span><br><span class="line">    </span><br><span class="line">    IWDG_ReloadCounter();  <span class="comment">//按照IWDG重装载寄存器的值重装载IWDG计数器（向 IWDG_KR 写入 0XAAAA）</span></span><br><span class="line">    </span><br><span class="line">    IWDG_Enable();  <span class="comment">//使能IWDG,启动看门狗(向 IWDG_KR 写入 0XCCCC)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//喂独立看门狗</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Feed</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">     IWDG_ReloadCounter();       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件iwdg.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __WDG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WDG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Init</span><span class="params">(u8 prer,u16 rlr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Feed</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主函数main.c：(不需要的头文件和函数直接删掉)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"key.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iwdg.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;     </span><br><span class="line"> </span><br><span class="line">     delay_init();               <span class="comment">//延时函数初始化     </span></span><br><span class="line">     LED_Init();                  <span class="comment">//初始化与LED连接的硬件接口 </span></span><br><span class="line">     KEY_Init();          <span class="comment">//按键初始化      </span></span><br><span class="line">     delay_ms(<span class="number">300</span>);         <span class="comment">//让人看得到灭</span></span><br><span class="line">     IWDG_Init(<span class="number">4</span>,<span class="number">625</span>);    <span class="comment">//与分频数为64,重载值为625,溢出时间为1s        </span></span><br><span class="line">     LED0=<span class="number">0</span>;                     <span class="comment">//点亮LED0</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(KEY_Scan(<span class="number">0</span>)==WKUP_PRES)</span><br><span class="line">       IWDG_Feed();<span class="comment">//如果WK_UP按下,则喂狗</span></span><br><span class="line">       delay_ms(<span class="number">10</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看门狗暂时只研究独立看门狗，因为有比赛任务，加紧学后面内容，有空补上。</p><hr><h2 id="stm32通用定时器"><a href="#stm32通用定时器" class="headerlink" title="stm32通用定时器"></a>stm32通用定时器</h2><p>简介：STM32 的通用定时器是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）<br>构成。 STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波<br>形(输出比较和 PWM)等。</p><p>timer.c时钟初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_Int_Init</span><span class="params">(u16 arr,u16 psc)</span>  <span class="comment">//方便参数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); <span class="comment">//时钟使能</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//初始化定时器参数,设置自动重装值， 分频系数，计数方式等</span></span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值     计数到5000为500ms</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  </span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim，TIM_ClockDivision针对的是外部输入分频（好像没什么用，先放着）</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM向上计数模式</span></span><br><span class="line">    TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); <span class="comment">//根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span></span><br><span class="line"> </span><br><span class="line">    TIM_ITConfig(  <span class="comment">//使能或者失能指定的TIM中断，设置 TIM3_DIER 允许更新中断。</span></span><br><span class="line">        TIM3, <span class="comment">//TIM2</span></span><br><span class="line">        TIM_IT_Update , <span class="comment">//更新中断</span></span><br><span class="line">        ENABLE  <span class="comment">//使能</span></span><br><span class="line">        );</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  <span class="comment">//TIM3中断</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;  <span class="comment">//先占优先级0级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;  <span class="comment">//从优先级3级</span></span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道被使能</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);  <span class="comment">//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span></span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM3, ENABLE);  <span class="comment">//使能TIMx外设</span></span><br><span class="line">                             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>   <span class="comment">//TIM3中断函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) <span class="comment">//检查指定的TIM中断发生与否:TIM 中断源 </span></span><br><span class="line">        &#123;</span><br><span class="line">        TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  <span class="comment">//清除TIMx的中断待处理位:TIM 中断源 </span></span><br><span class="line">        LED1=!LED1;  <span class="comment">//翻转led1状态</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件timer.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_Int_Init</span><span class="params">(u16 arr,u16 psc)</span></span>; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主函数main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;    </span><br><span class="line">    delay_init();             <span class="comment">//延时函数初始化</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<span class="comment">// 设置中断优先级分组2</span></span><br><span class="line">    LED_Init();              <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">    TIM3_Int_Init(<span class="number">4999</span>,<span class="number">7199</span>);<span class="comment">//10Khz的计数频率，计数到5000为500ms  </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED0=!LED0;</span><br><span class="line">        delay_ms(<span class="number">200</span>);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实验现象：led0大约每0.4秒闪烁一次（死循环操作的），led1大约1s闪烁一次（时钟中断操作：TIM3中断溢出，当 TIM3_CNT 的值等于 TIM3_ARR 的值的时候，就会产生 TIM3 的更新中断，<br>然后在中断里面取反 LED1， TIM3_CNT 再从 0 开始计数。）</p></blockquote><p>所以只要好好利用时钟中断的时间和中断处理函数，你就可以搞很多操作（比如，时间一到就溢出显示OLED数字，造成打字机效果等。）</p><hr><h2 id="PWM脉宽调制"><a href="#PWM脉宽调制" class="headerlink" title="PWM脉宽调制"></a>PWM脉宽调制</h2><p>原理看不完全手册本章，了解PWM是啥（之前51我没看相关的知识就跑过来32了）。<br>在此讲解一下代码中重要的点。</p><ol><li>选择PWM模式的时候，在捕获/比较模式寄存器（TIMx_CCMR1/2）中，设置模式设置位 OCxM，其中PWM模式两种，手册上说110/111，一开始没理解，后来在代码中寻址找到一下定义，看后面的地址应该懂了。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)</span><br><span class="line">#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)</span><br></pre></td></tr></table></figure>两种模式输出电平的极性相反，在中文手册中我粘贴了两种模式的说明：<blockquote><p>PWM模式1－ 在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为有效电平，否则为<br>无效电平；在向下计数时，一旦TIMx_CNT&gt;TIMx_CCR1时通道1为无效电平(OC1REF=0)，否<br>则为有效电平(OC1REF=1)。<br>模式2相反。给个图仔细观察：</p></blockquote><img src="/img/loading.gif" data-lazy-src="/stm32%E4%BB%A3%E7%A0%81/1.png" title="图示">。</li></ol><p>pwm.c代码：(PWM输出初始化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pwm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM1_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">    TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);<span class="comment">// </span></span><br><span class="line">     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA , ENABLE);  <span class="comment">//使能GPIO外设时钟使能</span></span><br><span class="line">                                                                             </span><br><span class="line">   </span><br><span class="line">   <span class="comment">//设置该引脚为复用输出功能,输出TIM1 CH1的PWM脉冲波形</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; <span class="comment">//TIM_CH1</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    TIM_TimeBaseStructure.TIM_Period = arr; <span class="comment">//设置在下一个更新事件装入活动的自动重装载寄存器周期的值     80K</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_Prescaler =psc; <span class="comment">//设置用来作为TIMx时钟频率除数的预分频值  (不分频)</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_ClockDivision = <span class="number">0</span>; <span class="comment">//设置时钟分割:TDTS = Tck_tim</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  <span class="comment">//TIM向上计数模式</span></span><br><span class="line">    TIM_TimeBaseInit(TIM1, &amp;TIM_TimeBaseStructure); <span class="comment">//根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//PWM2是在向上计数时，一旦TIMx_CNT&lt;TIMx_CCR1时通道1为无效电平，否则为有效电平；</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; <span class="comment">//选择定时器模式:TIM脉冲宽度调制模式2</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; <span class="comment">//比较输出使能</span></span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>; <span class="comment">//设置待装入捕获比较寄存器的脉冲值</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; <span class="comment">//输出极性:TIM输出比较极性高</span></span><br><span class="line">    TIM_OC1Init(TIM1, &amp;TIM_OCInitStructure);  <span class="comment">//根据TIM_OCInitStruct中指定的参数初始化外设TIMx</span></span><br><span class="line"></span><br><span class="line">    TIM_CtrlPWMOutputs(TIM1,ENABLE);    <span class="comment">//MOE 主输出使能    </span></span><br><span class="line"></span><br><span class="line">    TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  <span class="comment">//CH1预装载使能     </span></span><br><span class="line">    </span><br><span class="line">    TIM_ARRPreloadConfig(TIM1, ENABLE); <span class="comment">//使能TIMx在ARR上的预装载寄存器</span></span><br><span class="line">    </span><br><span class="line">    TIM_Cmd(TIM1, ENABLE);  <span class="comment">//使能TIM1</span></span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件pwm.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PWM_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM1_PWM_Init</span><span class="params">(u16 arr,u16 psc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>主函数main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pwm.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;    </span><br><span class="line">    u16 led0pwmval=<span class="number">0</span>;    </span><br><span class="line">    u8 dir=<span class="number">1</span>;    </span><br><span class="line">    delay_init();             <span class="comment">//延时函数初始化      </span></span><br><span class="line">    LED_Init();              <span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">    TIM1_PWM_Init(<span class="number">899</span>,<span class="number">0</span>);    <span class="comment">//不分频。PWM频率=72000/(899+1)=80Khz </span></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delay_ms(<span class="number">10</span>);     </span><br><span class="line">        <span class="keyword">if</span>(dir)led0pwmval++;</span><br><span class="line">        <span class="keyword">else</span> led0pwmval--;     </span><br><span class="line">        <span class="keyword">if</span>(led0pwmval&gt;<span class="number">300</span>)dir=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(led0pwmval==<span class="number">0</span>)dir=<span class="number">1</span>;                            </span><br><span class="line">        TIM_SetCompare1(TIM1,led0pwmval);       </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验现象：led0明暗交替，跟主程序计数有关，pwm改变占空比就是改变PA8输出的脉冲波形，造成明暗显示。</p><hr><h2 id="OLED显示"><a href="#OLED显示" class="headerlink" title="OLED显示"></a>OLED显示</h2><p>OLED，有机发光二极管，视频和PPT里有图，我买了mini配套的原版（16针的，可以适应多种接口方式）。从本章开始，我发现代码量开始大量提高，所以在我接下来的学习过程中，我力求理解关键的代码部分（能做到自主修改想要的操作部分，其他的会用就行）。</p><p>把OLED屏幕划分，显存总共为 128<em>64bit 大小，也可以想象成128</em>64这么多像素点，在确定位置的时候用。<br>如图：<img src="/img/loading.gif" data-lazy-src="/stm32%E4%BB%A3%E7%A0%81/2.jpg" title="图示"><br>对于现实内容的定义在主函数中的代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">0</span>,<span class="string">"helloworld"</span>,<span class="number">24</span>);  </span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">24</span>, <span class="string">"name:cjl"</span>,<span class="number">16</span>);  </span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">40</span>,<span class="string">"time:2020.7.22"</span>,<span class="number">12</span>);  </span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">52</span>,<span class="string">"my blog:"</span>,<span class="number">12</span>);  </span><br><span class="line">OLED_ShowString(<span class="number">48</span>,<span class="number">52</span>,<span class="string">"cjl520.top"</span>,<span class="number">12</span>);  </span><br><span class="line">OLED_Refresh_Gram();  <span class="comment">//更新显示到OLED</span></span><br></pre></td></tr></table></figure><p>前面两位参数代表在屏幕中显示的起始位置（内容往后覆盖），后一位参数显示字母的大小size。</p><p>给的代码中还有重复循环显示数字和ASCLL码的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OLED_ShowChar(<span class="number">32</span>,<span class="number">32</span>,t,<span class="number">12</span>,<span class="number">1</span>);<span class="comment">//显示ASCII字符</span></span><br><span class="line"><span class="comment">//后两位参数一个是size，一个是mode：0,反白显示;1,正常显示    </span></span><br><span class="line">OLED_ShowNum(<span class="number">94</span>,<span class="number">52</span>,t,<span class="number">3</span>,<span class="number">12</span>);<span class="comment">//显示ASCII字符的码值 </span></span><br><span class="line"><span class="comment">//后两位参数一个是数字所占长度len,一个是size。</span></span><br></pre></td></tr></table></figure><blockquote><p>所有显示出来的字母数字字符都需要建立库，对于每个字符的取模操作由 PCtoLCD2002 完美版，这个软件操作（自己实际操作）。选择合适的size后，在oledfont.h头文件中按模板格式创建好你所需要的并附上名字，然后在函数中修改定义：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定位置显示一个字符,包括部分字符</span></span><br><span class="line"><span class="comment">//x:0~127</span></span><br><span class="line"><span class="comment">//y:0~63</span></span><br><span class="line"><span class="comment">//mode:0,反白显示;1,正常显示                 </span></span><br><span class="line"><span class="comment">//size:选择字体 16/12 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OLED_ShowChar</span><span class="params">(u8 x,u8 y,u8 chr,u8 <span class="built_in">size</span>,u8 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;                      </span><br><span class="line">    u8 temp,t,t1;</span><br><span class="line">    u8 y0=y;</span><br><span class="line">    u8 csize=(<span class="built_in">size</span>/<span class="number">8</span>+((<span class="built_in">size</span>%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*(<span class="built_in">size</span>/<span class="number">2</span>);        <span class="comment">//得到字体一个字符对应点阵集所占的字节数</span></span><br><span class="line">    chr=chr-<span class="string">' '</span>;<span class="comment">//得到偏移后的值         </span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;csize;t++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">12</span>)temp=asc2_1206[chr][t];          <span class="comment">//调用1206字体</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">16</span>)temp=asc2_1608[chr][t];    <span class="comment">//调用1608字体</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">24</span>)temp=asc2_2412[chr][t];    <span class="comment">//调用2412字体</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;                                <span class="comment">//没有的字库</span></span><br><span class="line">        <span class="keyword">for</span>(t1=<span class="number">0</span>;t1&lt;<span class="number">8</span>;t1++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp&amp;<span class="number">0x80</span>)OLED_DrawPoint(x,y,mode);</span><br><span class="line">            <span class="keyword">else</span> OLED_DrawPoint(x,y,!mode);</span><br><span class="line">            temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            y++;</span><br><span class="line">            <span class="keyword">if</span>((y-y0)==<span class="built_in">size</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                y=y0;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改关键的else if即可。</p><blockquote><p>注意：我一开始取模的时候就想着能不能按照上面的代码，直接取模中文汉字，然后显示中文汉字，发现在“得到字体一个字符对应点阵集所占的字节数”上字符与中文有着细微的差别，中文字符是英文字符的两倍，但是修改后显示有一些异常，后来看了后面章节的中文显示代码有了启发，下次在这边补上。</p></blockquote><hr><h2 id="TFTLCD显示"><a href="#TFTLCD显示" class="headerlink" title="TFTLCD显示"></a>TFTLCD显示</h2><h2 id="ADC实验"><a href="#ADC实验" class="headerlink" title="ADC实验"></a>ADC实验</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Dragon6879</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cjl520.top/stm32%E4%BB%A3%E7%A0%81/">http://cjl520.top/stm32%E4%BB%A3%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cjl520.top" target="_blank">cjl's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/stm32/">stm32</a></div><div class="post_share"><div class="social-share" data-image="/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/stm32mini%E5%B0%8F%E8%BD%A60%E2%80%94%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/"><img class="prev-cover" data-lazy-src="/img/2.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">stm32mini四轮小车0—准备阶段以及HC-SR04模块</div></div></a></div><div class="next-post pull-right"><a href="/STM32%E7%9A%84ISP%E4%B8%8B%E8%BD%BD%E6%97%A0%E5%8F%8D%E5%BA%94/"><img class="next-cover" data-lazy-src="/img/7.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STM32的ISP下载无反应</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/stm32mini小车1—L298N电机/" title="stm32mini小车1—-L298N电机"><img class="relatedPosts_cover" data-lazy-src="/img/2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-16</div><div class="relatedPosts_title">stm32mini小车1—-L298N电机</div></div></a></div><div class="relatedPosts_item"><a href="/stm32mini小车0—准备阶段/" title="stm32mini四轮小车0—准备阶段以及HC-SR04模块"><img class="relatedPosts_cover" data-lazy-src="/img/2.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-13</div><div class="relatedPosts_title">stm32mini四轮小车0—准备阶段以及HC-SR04模块</div></div></a></div><div class="relatedPosts_item"><a href="/STM32的ISP下载无反应/" title="STM32的ISP下载无反应"><img class="relatedPosts_cover" data-lazy-src="/img/7.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-08</div><div class="relatedPosts_title">STM32的ISP下载无反应</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image:url(/img/5.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Dragon6879</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div><div class="footer_custom_text">亿万次的回眸才等到你！</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '7VXnTLWX85gsuMybqKDkJ8bw-gzGzoHsz',
      appKey: 'CaYTeDA5OgUg0XumN5217eYi',
      placeholder: '留下你的宝贵意见吧！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/js/third-party/ClickShowText.js" async></script></div></body></html>